---
layout: post
title:  MySQL 基础 
date:   2020-4-22
categories: MySQL
tags:  MySQL
---
* content
{:toc}








# 语法

## 关系数据库

关系数据库（Relational database）是指基于关系模型的数据库。关系模型由**关系数据结构（二维表）、关系操作集合、关系完整性约束**三部分组成。

常见的数据操作包括增加（Create）、查询（Retrieve）、更新（Update）以及删除（Delete），或者统称为增删改查（CRUD）。

为了维护数据的完整性和精确性，或者为了实现业务需求，SQL 标准定义了 6 种完整性约束。

- **非空约束**（NOT NULL），用于确保字段不会出现空值。例如学生信息表中，学生的姓名、出生日期、性别等一定要有数据。
- **唯一约束**（UNIQUE），用于确保字段中的值不会重复。例如每个学生的身份证、手机号等需要唯一。
- **主键约束**（Primary Key），用 于唯一标识表中的每一行数据。例如学生信息表中，学号通常作为主键。主键字段不能为空并且唯一，每个表可以有且只能有一个主键。
- **外键约束**（Foreign Key），用于建立两个表之间的参照完整性。例如学生属于班级，学生信息表中的班级字段是一个外键，引用了班级表的主键。对于外键引用，被引用的数据必须存在，学生不可能属于一个不存在的班级。
- **检查约束**（CHECK）可以定义更多的业务规则。例如，性别的取值只能为“男”或“女”，用户名必须大写等；
- **默认值**（DEFAULT）用于为字段提供默认的数据。例如，玩家注册时的级别默认为 1 级。



## SQL 语句分类

常见的 SQL 语句包含以下类别：

- `DQL`（data query language），数据查询语言；主要是`SELECT`语句，用于查询数据库中的数据和信息。
- `DML`（data manipulation language），数据操作语言；主要用于对数据库进行数据的增加、修改和删除，包括`INSERT`、`UPDATE`、`DELETE`和`MERGE` 等语句。
- `DDL`（data definition language），数据定义语言；主要用于定义数据库中的模式对象，例如表或索引，包括`CREATE`、`ALTER`、`DROP`等等
- `TCL`（transaction control language），事务控制语言；用于管理数据库事务，主要包含`BEGIN TRANSACTION`、`COMMIT`、`ROLLBACK`、`SAVEPOINT`等语句。
- `DCL`（data control language），数据控制语言；用于控制数据的访问权限，主要有`GRANT`、`REVOKE`等语句。







## 数据类型

### 数据类型概述

关系型数据库中，用于存储数据的主要对象是表（table），表由行（row）和列（column）组成。

数据行，也称为记录（record）、元组（tuple），是二维表格中的行。表中的一行对应现实世界中的一个实体。

表中的每个列都拥有一个数据类型，数据类型定义了该列能够存储的数据值，以及允许执行的操作。常见的数据类型包括字符类型、数字类型、日期时间类型等。其中，数字类型可以进行加减乘除等数学运算，日期时间类型可以进行格式化显示。

SQL标准中定义的数据类型可以分为三类:

- 预定义数据类型（predefined data type）
- 构造数据类型（constructed data type）
- 自定义数据类型（user-defined data type）



### 预定义数据类型

- `CHARACTER`、`CHARACTER VARYING` 以及 `CHARACTER LARGE OBJECT` 统称为字符串类型，它们存储的值为字符串。
- `BINARY`、`BINARY VARYING` 以及 `BINARY LARGE OBJECT`统称为二进制串类型，它们存储的值为二进制串。
- `CHARACTER LARGE OBJECT` 以及 `BINARY LARGE OBJECT`统称为大对象串类型，它们存储的值为大对象串。
- `NUMERIC`、`DECIMAL`、`DECFLOAT`、`SMALLINT`、`INTEGER`以及BIGINT统称为精确数字类型。
- `FLOAT`、`REAL` 以及 `DOUBLE PRECISION`统称为近似数字类型。精确数字类型和近似数字类型统称为数字类型。
- `TIME WITHOUT TIME ZONE`以及` TIME WITH TIME ZONE` 统称为时间类型（不包含时区的时间和包含时区的时间）。
- TIMESTAMP WITHOUT TIME ZONE以及TIMESTAMP WITH TIME ZONE统称为时间戳类型（不包含时区的时间戳和包含时区的时间戳）。
- `DATE`、`TIME以及 `TIMESTAMP` 统称为日期时间类型，它们存储的值为日期时间。
- `INTERVAL` 称为时间间隔类型，存储的值为时间间隔。
- `DATALINK` 称为数据链接类型，用于访问存储在数据库之外的资源。
- `XML` 称为XML类型，存储的值为XML值。

#### 字符串类型

##### **定长字符串**

SQL标准中关于固定长度字符串的定义如下：

```sql
CHARACTER [ ( n ) ]
--或者
CHAR [ ( n ) ]
```

其中，`CHARACTER`和`CHAR`是同义词，表示固定长度字符串；*n* 表示字符串的长度。

对于固定长度字符串，如果输入的字符串长度不够，将会使用空格进行填充。

> 在实际使用时，应该尽量避免使用定长字符串类型。

##### **变长字符串**

变长字符串类型用于存储长度不固定的字符串，例如名字。SQL标准中关于可变长度字符串的定义如下：

```sql
VARCHAR [ ( n ) ]
-- 或者
CHAR VARYING [ ( n ) ]
```

其中，*n* 表示字符串的最大长度。

对于可变长度字符串，如果输入的字符串长度不够，存储实际的内容。

##### **数字类型**

数字主要分为两类：精确数字，包括`NUMERIC`、`DECIMAL`、`DECFLOAT`、`SMALLINT`、`INTEGER`和`BIGINT`；以及近似数字，包括`FLOAT`、`REAL`和`DOUBLE PRECISION`。



##### **二进制类型**

二进制类型分为定长二进制串`BINARY`、变长二进制串`BINARY VARYING`、二进制大对象`BINARY LARGE OBJECT`。

```sql
BINARY [ ( n ) ]

BINARY VARYING [ ( n ) ]
VARBINARY [ ( n ) ]

BINARY LARGE OBJECT [ ( n ) ]
BLOB [ ( n ) ]
```



##### **近似数字**

近似数字也称为浮点型数字，主要用于科学计算。SQL标准中定义了3种浮点类型。

```sql
FLOAT [ ( p ) ]
REAL
DOUBLE PRECISION
```



##### **布尔类型**

SQL标准使用三值布尔逻辑：`true`、`false`以及`unknown`。`unknown`使用`NULL`值表示。



##### **日期时间类型**

与日期和时间相关的数据类型包括：`DATE`、`TIME`以及`TIMESTAMP`。

`DATE`存储年、月、日；`TIME`存储时、分、秒，以及秒的小数部分；`TIMESTAMP`同时包含年、月、日、时、分、秒，以及秒的小数部分。







## **登录退出**

　操作数据库的第一步是登录数据库，通常需要提供一个MySQL用户名和密码。如果服务器运行在登录服务器之外的其它机器上，还需要指定主机名

> 　　[注意]在退出数据库之后，cmd清空屏幕的操作是输入cls(相当于clear screen)



  参数             描述

- -D            (database)打开指定数据库
- -h            (host)服务器名称
- -p            (password)密码
- -P            (port)端口号
- -u            (user)用户名
- -V            (version)输出版本信息并退出

## 语句规范

在操作数据库之前，要先了解数据库的语句规范，主要有以下三条

1. 关键字与函数名称全部大写

2. 数据库名称、表名称、字段名称全部小写

3. SQL语句必须以分号结尾

## 常用命令

mysql 数据库有以下三个常用命令:

- `SELECT VERSION();`         显示当前服务器版本 

- `SELECT NOW();`             显示当前日期时间 

- `SELECT USER(); `           显示当前用户

## 数据库操作

### 创建数据库

关键字 ：`CREATE`

```python
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name 
      [DEFAULT] CHARACTER SET [=] charset_name
```

### **使用和切换当前数据库**

创建数据库并不表示选定并使用它，必须明确地操作，所以数据库操作的第二步是选择数据库

```sql
USE db_name
```

切换数据库 use db_name;  

注意：进入到某个数据库后没办法再退回之前状态，但可以通过use进行切换 。

查看当前使用的数据库

```sql
 select database();
```



### **看下服务器下的数据库列表**

```python
SHOW {DATABASES | SCHEMAS} [LIKE 'pattern' | WHERE expr]
```



### **修改数据库**

```python
ALTER {DATABASE | SCHEMA} [db_name] [DEFAULT] CHARACTER SET [=] charset_name
```

(1) 增加列(字段)

```python
alter table tab_name add [column] 列名 类型［完整性约束条件］［first｜after 字段名］;

alter table user add addr varchar(20) not null unique first/after username;
```

### 添加多个字段

```python
alter table users2 
		add addr varchar(20),
		add age  int first,
		add birth varchar(20) after name;
```


(2) 修改一列类型

```python
alter table tab_name modify 列名 类型 [完整性约束条件]［first｜after 字段名］;

alter table users2 modify age tinyint default 20;
alter table users2 modify age int  after id;
```

(3) 修改列名

```python
alter table tab_name change [column] 列名 新列名 类型 [完整性约束条件]［first｜after 字段名］;
alter table users2 change age Age int default 28 first;
```











### **删除数据库的操作**

```sql
DROP {DATABASE | SCHEMA} [IF EXISTS] db_name

drop database [if exists] db_name;

```

------



## 数据表操作

### 创建数据表

在 SQL 中，使用 `CREATE TABLE` 语句创建表：

下面在db1数据库中创建数据表tb1

> 
> CREATE  TABLE  [IF NOT EXISTS]  table_name(column_name data_type,...)
> 

```sql
CREATE TABLE table_name
(
  column_1 data_type column_constraint,
  column_2 data_type,
  ...,
  table_constraint
);

```

首先，需要指定一个新的表名 table_name；括号内是字段的定义，包括字段名、数据类型以及可选的约束，多个字段使用逗号进行分隔；最后还可以定义基于表的约束。

以下语句用于创建表 departments：

```sql
CREATE TABLE departments
    ( department_id    INTEGER NOT NULL PRIMARY KEY
    , department_name  CHARACTER VARYING(30) NOT NULL
    , manager_id       INTEGER
    , location_id      INTEGER
    ) ;

```







### **查看数据表**

```sql
SHOW TABLES [FROM db_name] [LIKE 'pattern' | WHERE expr]

desc tab_name 查看表结构
show columns from tab_name  查看表结构
show tables 查看当前数据库中的所有的表
```



### **查看数据表的列项**

> 
> SHOW COLUMNS FORM  tbl_name
> 



### **记录操作**

SQL 标准中提供了 3 种数据插入的方法：

1. `INSERT INTO … VALUES;`
2. `INSERT INTO … SELECT;`
3. `INSERT INTO … DEFAULT;`

#### **插入单条记录**

记录操作的第一步是写入记录

　　在写入记录时，要注意的是，如果没有省略的字段，则按照参数顺序直接赋值即可；如果有省略的字段，则字段名和参数值都需要写出来

> 
> INSERT [INTO] tbl_name   [(col_name,...)]   VALUES(VAL,...)
> 

```python
insert into employee_new (id,name,birthday,salary) values
	(1,'yuan','1990-09-09',9000);

-- 如果值列表与表中的字段顺序完全一致，可以省略字段列表
insert into employee_new values
	(2,'alex','1989-08-08',3000);

insert into employee_new (name,salary) values
	('xialv',1000);
```

#### **插入多条数据**

```python
insert into employee_new values
	(4,'alvin1','1993-04-20',3000),
	(5,'alvin2','1995-05-12',5000);
```

set 插入: insert ［into］ tab_name set 字段名=值

一次性只能插入一条记录

```python
insert into employee_new set id=12,name="alvin3";
```









#### **更新记录**

SQL 标准提供了 `UPDATE` 语句，用于更新表中的数据。基本语法如下：

> ```sql
> UPDATE t
>    SET column1 = expr1,
>        column2 = expr2,
>        ...
> [WHERE condition];
> 
> ```

其中，t 是要更新数据的表名；`SET` 子句指定了要更新的列和更新后的值，多个字段使用逗号进行分隔；满足 `WHERE` 条件的数据行才会被更新，如果没有指定条件，将会更新表中所有的行。





#### **删除记录**

要删除表中的数据，使用 `DELETE` 语句。

> DELETE FROM tbl_name [WHERE where_condition]
> 
> 只有满足 `WHERE` 条件的数据才会被删除；如果省略 `WHERE` 条件，将会删除表中所有的数据。

```python
delete from users where id=6;
```

> [注意] 删除某条记录后，再插入一条新的记录，自动编号不会补到删除记录的编号上，而是基于原有记录最大编号继续增加 。

在删除数据之前，可以使用相应的 `SELECT` 语句查看将要删除的数据。



#### **合并数据**

在 SQL:2003 标准中，引入了一个新的数据操作命令：`MERGE` 。它可以同时完成 `INSERT` 和 `UPDATE` 的操作，甚至 `DELETE` 的功能。





#### **查找记录**

```sql
SELECT EXPR,...FROM tbl_name

SELECT select_expr [,select_expr...]
[
FROM tbl_references
[WHERE where_condition]
[GROUP BY {col_name | position} [ASC | DESC],...]
[HAVING where_condition]
[ORDER BY {col_name | expo | position}  [ASC | DESC],...]
[LIMIT {[offset,] row_count | row_count OFFSET offset}]
]
```



查询表达式的每个表达式表示想要查找的一列，必须有至少一个。多个列之间以英文逗号分开， 查询 id, username 两列。

```sql
select id, username from users;
```

在使用多表连接时，可能会出现不同的表中存在名称相同的字段，如果直接写字段，分不清到底是哪张数据表的字段。在字段名前加上数据表可以分辨出隶属于哪张数据表。

```sql
select users,id, users, username from users;
```

星号`*`号表示所有的列。`tbl_name.*` 可以表示命名表的所有列 .

```sql
select * from users;
```

查询表达式可以使用 [AS] alias_name 为其赋予别名，别名可用于 `GROUP BY`, `ORDER BY`, `HAVING` 字句 .

```sql
select id AS userId, username AS uname from users;
```



##### **消除重复值**

在 SQL 中，提供了`DISTINCT`关键字，用于删除查询结果中的重复值。例如：

```sql
SELECT DISTINCT
		first_name
	FROM employees;
```

`DISTINCT`位于`SELECT`之后，可以基于多个列值进行查重操作，通用语法如下：

```sql
SELECT DISTINCT
		column1,
		column2,
		...
	FROM table;
```

为了消除重复值，数据库系统需要对结果进行排序，然后扫描重复值；因此，大量数据的重复值处理会降低查询的速度。

除了`DISTINCT`之外，另一个关键字是`ALL`，它不会排除重复的结果，而是显示所有数据：

```sql
SELECT [ALL | DISTINCT]
		column1,
		column2,
		...
	FROM table;
```

如果不指定，默认值为`ALL`。

#### **SQL中的注释**

在 SQL 中，可以像其他编程语言一样使用注释，注释不会被执行。

SQL 中的注释分为单行注释和多行注释。

单行注释以两个连字符（`–`）开始，直到这一行结束。例如：

```sql
SELECT DISTINCT
		first_name --distinct will remove duplicate records
	FROM employees
```

多行注释使用C语言风格的注释方法（`/* … */`）。例如：

```sql
SELECT DISTINCT
		first_name
		/* distinct will remove
		   duplicate records from results
		*/
	FROM employees;
```

上面的查询中，总是返回表中的全部数据。但是更多情况下，我们只需要查看满足一定条件的结果。SQL中的`WHERE`关键字用于指定查询的条件。

#### **结果处理**

##### **数据分组**

`GROUP BY`子句，将数据分成不同的组，然后分别计算各个组内的聚合函数。

```sql
[GROUP BY {col_name | position} [ASC | DESC],...]
```

查询结果分组 (`GROUP BY`) 的参数中，`ASC` 是升序，是默认的；`DESC` 是降序

```sql
select * from users GROUP BY ager;

select * from users GROUP BY age DESC;
```

col_name 代表字段名，position 以数字代表位置，如 1 代表 SELECT 语句中第一次出现的字段。

```sql
select password, id, username, from users GROUP BY 1;
```

假如我们想要知道不同部分的平均薪水，而不是所有员工的平均值，可以使用以下语句：

```sql
SELECT department_id,
		AVG(salary)
	FROM employees
	GROUP BY department_id;
```

> 如果`GROUP BY`后的分组字段存在 NULL 值，多个 NULL 值将被看作一个分组。

在SQL查询中，如果同时存在`WHERE`子句和`GROUP BY`子句，要求`WHERE`子句在`GROUP BY`子句之前。因此，`WHERE`子句无法对分组后的结果进行过滤，例如：

##### **分组过滤**

假设要查看员工数量大于 10 的部门编号，可以使用以下查询：

```sql
SELECT department_id,
		COUNT(*) AS headcount
	FROM employees
	GROUP BY department_id
	HAVING COUNT(*) > 10;
```

首先，按照部门编号进行分组，计算每个组内的员工数量；然后使用`HAVING`子句过滤员工数量大于 10 人的部门

假如要查看薪水大于 8000 的员工，数量大于 10 的部门编号，可以使用以下查询：

```sql
SELECT department_id,
		COUNT(*) AS headcount
	FROM employee
   WHERE salary > 8000
   GROUP BY department_id
 HAVING COUNT(*) > 10;
```

首先，`WHERE`子句过滤薪水大于 8000 的所有员工；然后，按照部门编号进行分组，计算每个组内的员工数量；最后，使用`HAVING`子句过滤员工数量大于 10 人的部门。



##### **分组条件**

> [HAVING where_condition]

在设置分组 (`HAVING`) 时，一定要保证分组条件 (where_condition) 要么是聚合函数(max, min, avg, count, sum)，要么其中的字段必须是 SELECT 中的一个查询字段，否则会报错

![](https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426083828.png)

```sql
SELECT column1, column2,...
	FROM table
	WHERE conditions;
```

简单的示例：

```sql
SELECT first_name,
		last_name,
	FROM employees
   WHERE last_name = 'King';

```

在`WHERE`子句的条件中，允许使用各种比较运算符。



SQL 标准的语法：

```sql
SELECT column1,
       column2,
       aggregate_function(column3)
  FROM table1
[WHERE conditions]
[GROUP BY column1, column2]
[HAVING group_condition];

```



> 

 



##### 限制结果

SQL 标准中对查询结果进行限制的`OFFSET`子句和`FETCH`子句

```sql
[LIMIT {[offset,] row_count | row_count OFFSET offset}]
```



限制查询结果 (`LIMIT`) 默认情况下，返回所有查找到的结果

如果 `LIMIT` 后面只有一个数字，表示从第一条开始返回，并返回相应数字个数的记录

```sql
select * from usres limit 2;
```

从第一条开始，返回两条记录。

`SELECT` 语句默认从0开始编号，如果想从第三条开始返回，则需要 offset 参数和 row_count 参数一起使用

```sql
select * from usres limit 2,2;

SELECT first_name, last_name, salary
  FROM employees
 ORDER BY salary DESC
 LIMIT 5, 10; -- return from 5th to 14th
 -- LIMIT 10 OFFSET 5;
```



###### Top-N 查询

由于不同数据库的实现存在较大差异, 先以 Oracle 12c 语法为例

```sql
SELECT first_name, last_name, salary
	FROM employees
	ORDER BY salary DESC
	FETCH FIRST 10 ROWS ONLY;
```

以上查询返回薪水最高的前 10 位员工。首先，`ORDER BY`子句定义了按照薪水从高到低排序；然后`FETCH`子句指定了只返回前 10 条记录。

###### 分页查询

考虑另一个场景，假如应用提供了分页显示的功能，每页显示 10 条记录，点击下一页时，需要显示第 11 到第 20 条记录。

```sql
SELECT first_name, last_name, salary
  FROM employees
 ORDER BY salary DESC
OFFSET 10 ROWS
 FETCH FIRST 10 ROWS ONLY;
```



SQL 标准中的完整定义：

```sql
SELECT column1, column2, ...
  FROM table
[WHERE conditions]
[ORDER BY column1 ASC, column2 DESC, ...]
[OFFSET m {ROW | ROWS}]
[FETCH { FIRST | NEXT } [ num_rows | n PERCENT ] { ROW | ROWS } { ONLY | WITH TIES }];

```

其中，`OFFSET` 表示偏移量，即从第 m+1 行开始返回；如果不指定，从第 1 行开始返回。

`FETCH` 用于指定返回多少行，`FIRST` 和`NEXT` 等价；num_rows 表示行数，n PERCENT 表示即按照百分比指定行数，`ROW` 和`ROWS` 等价；`ONLY` 和`WITH TIES` 的差别在于，如果最后存在更多排名相同的数据行，`WITH TIES`会返回更多的数据。

以下查询按照百分比返回前10%的数据：

```sql
SELECT first_name, last_name, salary
	FROM employees
	ORDER BY salary DESC
	FETCH FIRST 10 PERCENT ROWS ONLY;
```



##### 补充

> 
> INSERT [INTO] tbl_name [(col_name,...] SELECT ...
> 

这种方法可以将查找的结果存储到指定的数据表

```sql
create table t(
    id tinyint primary key ayto_increment,
    username varchar(20)
);

insert t(username) select username from users where age > 30;
```

将表 users 中符合条件的用户名插入到表 t 中。



### 记录约束

#### **空值**

> NULL         字段值可以为空
> NOT NULL     字段值禁止为空

#### **主键**

每张数据表只能存在一个主键 (`PRIMARY KEY`)，主键保证记录的唯一性，且自动为 NOT NULL

主键可以写为 `KEY` 或  `PRIMARY KEY`

```sql
create table tb(
	id smallint primary key,
    uername vahcar(20) not null
);
```

#### **自动编号**

自动编号 (`AUTO_INCREMENT`) 必须与主键组合使用，默认情况下，起始值为1，每次增量为1

```sql
create table tb(
	id smallint auto_increment  primary key,
    uername vahcar(20) not null
);
```



#### **唯一**

唯一约束 (`UNIQUE KEY`) 是指选定的记录中不可以存在相同值的情况，这样可以保证记录的唯一性，唯一约束的字段可以为空值 NULL，每张数据表可以存在多个唯一约束

#### **默认值**

当插入记录时，如果没有明确为字段赋值，则自动赋予默认值 (`DEFAULT`)

```sql
create table tb6(
	id int unsigend auto_increment key,
    username vachar(20) not null unique key,
    sex enum('1','2','3') default '3'
);
```



#### **外键**

外键约束 (`FOREIGN KEY`) 用来保持数据一致性和完整性，实现一对一或一对多的关系

外键列是指加入 (`FOREIGN KEY`) 的列，外键列参照的那一列叫做参照列，外键列和参数列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同



外键列和参照列必须创建索引，如果参照列不存在索引的话，MySQL将自动创建索引 。

子表指有外键列的表，子表所参照的表叫做父表。父表和子表必须使用相同的存储引擎，而且禁止使用临时表。数据表的存储引擎只能是 InnoDB 

**主表**

```sql
CREATE TABLE ClassCharger(

       id TINYINT PRIMARY KEY auto_increment,
       name VARCHAR (20),
       age INT ,
       is_marriged boolean  -- show create table ClassCharger: tinyint(1)

);

INSERT INTO ClassCharger (name,age,is_marriged) VALUES ("冰冰",12,0),
                                                       ("丹丹",14,0),
                                                       ("歪歪",22,0),
                                                       ("姗姗",20,0),
                                                       ("小雨",21,0);
```

**子表**

```sql
CREATE TABLE Student(

       id INT PRIMARY KEY auto_increment,
       name VARCHAR (20),
       charger_id TINYINT,     --切记:作为外键一定要和关联主键的数据类型保持一致
       -- FOREIGN KEY (charger_id)  REFERENCES ClassCharger(id)

) ENGINE=INNODB;

INSERT INTO Student(name,charger_id) VALUES ("alvin1",2),
                                            ("alvin2",4),
                                            ("alvin3",1),
                                            ("alvin4",3),
                                            ("alvin5",1),
                                            ("alvin6",3),
                                            ("alvin7",2);
```

#### **增加外键和删除外键**

```sql
ALTER TABLE student  ADD CONSTRAINT abc
                     FOREIGN KEY(charger_id)
                     REFERENCES  classcharger(id);

ALTER TABLE student DROP FOREIGN KEY abc;
```



#### 添加主键约束

> ALTER TABLE tb1_name ADD  PRIMARY KEY (index_col_name,...)

#### 添加唯一约束

唯一约束与主键约束的不同之处在于，唯一约束可以存在多个字段，而主键约束只能有一个

> ALTER TABLE tb1_name ADD  UNIQUE [INDEX|KEY] [index_name] [index_type]



#### **添加外键约束**

>ALTER TABLE tb1_name ADD [CONSTRAINT[symbol]] FOREIGN KEY [index_name] (index_col_name,...) reference_definition

```
alter table user2 add foreign key (pid) references provinces(id);
```

*provinces 为另一个表名



#### 删除主键约束

> ALTER TABLE tbl_name DROP PRIMARY KEY

#### 删除唯一约束

```sql
ALTER TABLE tbl_name DROP {INDEX|KEY} index_name;
```

#### **删除外键约束**

> ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol





## **列操作**

### 单列排序

通过`SELECT`语句返回的查询结果，不保证结果的顺序。如果想要对查询结果进行排序显示，需要使用`ORDER BY`子句。

```sql
SELECT column1, column2, ...
	FROM table
  [WHERE condition]
  ORDER BY column1 ASC;
```

`ORDER BY`子句唯一`FROM`之后；如果查询包含`WHERE`条件，`ORDER BY`子句位于`WHERE`之后。`ASC`表示按照升序排序，`DESC`表示安装降序排序。默认为升序排序。

可以使用分组排序(order by)对查询结果进行排序

```sql
select * from users order by age;
```

除了按照列进行排序之外，也可以使用表达式的值进行排序。

### 多列排序

ORDER BY 也可以指定多个排序的字段。

```sql
SELECT column1, column2, ...
	FROM table
   [WHERE condition]
   ORDER BY column1 ASC, column2 DESC;
```

如果指定多列排序，首先按照第 1 个指定的列进行排序，顺序相同的数据再按照第 2 个指定的列进行排序，以此类推。

除了使用列名指定排序顺序之外，SQL 还支持使用列在`SELECT`后出现的次序进行排序。例如

```sql
SELECT first_name,
		last_name,
		hire_date
	FROM employees
	ORDER BY 1 DESC, 2;
```

因为 first_name 在`SELECT`列表中第 1 个出现，last_name 第 2 个出现。

对于排序，需要注意的是字符串的大小写；有些数据库区分大小写，有些不区分。许多数据库还支持指定排序规则（COLLATE）。

> MySQL不区分大小写，“CAT”和“cat”相同
> MySQL升序排序时空值排在最前，降序排序时空值排在最后

### 添加单列

```sql
ALTER TABLE tb!_name ADD[COLUMN] col_name column_definition [FIRST|AFTER col_name];
```



添加单列有三个位置选择，位于起始处，位于指定列的后面和位于最后

`FIRST` 加入的放在整张表最前面，`AFTER` 放在指定列后面，不填则放在整张表最后

### 添加多列

> 
> ALTER TABLE tb1_name ADD[COLUMN] (col_name column_definition,...);
> 

添加多列只能位于最后 。

### **删除单列**

> 
> ALTER TABLE tb1_name DROP [COLUMN] col_name
> 

### 删除多列

> 
> ALTER TABLE tb1_name DROP col1_name, DROP col2_name, ...
> 



### 修改列

#### 修改列定义

对于一个已有的表，可能会由于业务变更或者代码重构需要修改它的结构。

修改列定义指修改列的类型或位置

> 
> ALTER TABLE table_name action;
> 

其中的 action 表示要对表执行的操作，常见的操作包括增加列，修改列，删除列；增加约束，修改约束，删除约束等等。



将字段 'id' 的类型由 smallint 转换为 tinyint

> [注意]在由大范围的类型转换为小范围类型时，可能会造成数据丢失

```sql
alter table1 user2 modify id tinyint unsigend not null
```

首先是为表增加一个新的字段：

```sql
ALTER TABLE table_name
	ADD [COLUMN] column_name date_type column_constraint;
```

添加字段的内容和创建表时类似，包括字段名、数据类型以及可选的列约束。

> MySQL 支持为新增的列指定位置：
>
> `ALTER TABLE table_name`
>
> `ADD [COLUMN] column_name data_type column_constraint FIRST `
>
> `| AFTER some_column;`

有时候我们需要修改表中字段的某些属性，比如数据类型，约束等。SQL 使用 `ALETR TABLE ... ALTER COLUMN` 语句修改字段的属性：



#### 修改列名称

使用下面的 CHANGE 语法，比 MODIFY 语法更加强大，可以在修改列名称的同时，修改列类型 。

```sql
ALTER TABLE tb1_name CHANGE  old_col_name new_col_name column_definition [FIRST|AFTER col_name]
```



```sql
ALTER TABLE emp_identity RENAME COLUMN last_name TO family_name;
```





## 数据表更名

```sql
ALTER TABLE tb1_name RENAME [TO|AS] new_tb1_name
```



使用 RENAME 方法可以为多张数据表更名

> 
> RENAME TABLE tb1_name TO new_tbl_name [,tbl_name2 TO new_tbl_name2] ...
> 



## 中文乱码问题

### 配置文件

解决中文识别问题的第一步是修改 mysql 的配置文件 my.ini

在 [client] 下添加

```sql
default-character-set = utf8
```

在 [mysqld] 下添加

```sql
character-set-server = utf8
```

然后重新启动服务

### 数据库编码

新建一个数据库

```sql
create database db4
```

通过下列代码查看数据库的编码类型

```sql
show create database db4
```

查看编码类型是否是 utf8，如果不是，则使用下列代码修改为 utf8

```sql
set names utf8
```

### 数据表编码

新建数据表

```sql
create table if not exists tdb
```

查看数据表的编码类型

```sql
show cearte tabel tdb
```

查看编码类型是否是 utf8，如果不是，则使用下列代码修改为 utf8

```sql
SET NAMES utf8
```

## 子查询

查询数据库，当查询条件比较复杂时，常常需要用到子查询。子查询 (Subquery) 是指出现在其他 SQL 语句内的 `SELECT` 子句。

### 定义

子查询 (Subquery) 是指出现在其他 SQL 语句内的 SELECT 子句

```sql
SELECT * FROM t1 WHERE col1 = (SELECT col2 FROM t2);
```

其中，`SELECT * FROM t1`，称为外层查询(Outer Query/Outer Statement)，`SELECT col2 FROM t2` ，称为子查询 (SubQuery)



在使用子查询时，需要注意的是

1. 子查询指嵌套在查询内部，且必须始终出现在圆括号内

2. 子查询语句中可以包含多个关键字或条件，如 `DISTINCT`、`GROUP BY`、`ORDER BY`、`LIMIT`、函数等

3. 子查询的外层查询可以是：`SELECT`、`INSERT`、`UPDATE`、`SET` 或 `DO`

4. 子查询返回值可以是：标量、一行、一列或者子查询

假设我们想要知道哪些员工的薪水大于所有员工薪水的平均值。首先，我们可以查询出所有员工的平均薪水值：

```sql
SELECT AVG(salary)
 FROM employees;
```

结果约为 6462 。然后，我们查询那些薪水大于该值的员工信息：

```sql
SELECT first_name,
		last_name,
		salary
	FROM employees
  WHERE salary > 6462
  ORDER BY salary;
```

以上示例中我们使用了两个查询来解决问题，但是实际问题往往更加复杂；通过使用子查询，可以一次解决问题，同时还能实现更多功能：

```sql
SELECT first_name,
	   last_name,
	   salary
	FROM employees
  WHERE salary > (
      			SELECT AVG(salary)
        		FROM employees  
  	  		)
  ORDER BY salary;
```

以上查询包含两个`SELECT`语句，括号内部的查询称为子查询，子查询也称为内查询（inner query）或者嵌套查询（nested query），包含子查询的查询称为外查询（outer query）。

在 SQL 标准定义中，子查询分为以下类型：

- **标量子查询（scalar query）**：返回单个值（一行一列）的子查询。上面的示例就是一个标量子查询。
- **行子查询（row query）**：返回包含一个或者多个值的单行结果（一行多列），标量子查询是行子查询的特例。
- **表子查询（table query）**：返回一个虚拟的表（多行多列），行子查询是表子查询的特例。


### 标量子查询

标量子查询可以当作一个标量值使用。

#### SELECT 子句中的标量子查询

```sql
SELECT first_name,
		last_name,
		salary,
		salary - (SELECT ROUND(AVG(salary),0)
					FROM employees) AS difference
	FROM employees
  ORDER BY first_name, last_name;
```

#### WHERE 子句中的标量子查询

在 SQL 语句的`WHERE`子句中，可以将列值与一个标量子查询的结果进行比较运算，返回满足条件的数据：

```sql
SELECT first_name,
		last_name,
		salary
	FROM employees
  WHERE salary = (SELECT MAX(salary)
                 	FROM employees)
  ORDER BY first_name, last_name;
```

标量子查询除了用于`SELECT`和`WHERE`子句之外，也可以出现在`GROUP BY`、`HAVING`以及`ORDER BY`子句中，使用方法类似。



### 行子查询

行子查询可以当作一个一行多列的表使用。

```sql
SELECT first_name,
		last_name,
		salary
	FROM employees
  WHERE (first_name, last_name) = 
  				(SELECT MAX(first_name), MAX(last_name)
                	FROM employees
                )
 ORDER BY first_name, last_name;
```

以上查询中的子查询返回一个一行两列的值，然后在外查询的`WHERE`条件中查找姓和名都匹配该值的员工信息。

**对于使用行子查询或标量子查询的情况，需要注意子查询结果不能返回多行**。



### 表子查询

表子查询可以当作一个表使用。

#### FROM 子句中的表子查询

在 FROM 子句中的子查询，相当于创建了一个临时表，可以作为查询的一个数据源使用：

```sql
SELECT column1, column2, ...
  FROM (subquery) [AS table_alias];

```

示例

```sql
SELECT d.department_name,
		ds.sum_salary
	FROM department d
	JION (SELECT department_id,
         		 SUM(salary) AS sum_salary
         	FROM employees
           GROUP BY department_id) ds
      ON (d.departmrnt_id = ds.department_id)
    ORDER BY d.derpartment_name;
        
```

> 不同数据库产品对于 FROM 子句中的子查询称呼不同。例如，MySQL 称为派生表（derived table）

#### WHERE 子句中的表子查询

如果子查询返回多行记录，不能使用普通的比较运算符（例如等于）进行判断；需要使用其他运算符。

首先，我们可以使用`[NOT] IN`检查某个值是否包含在列表中：

```sql
SELECT first_name,
       last_name,
       salary
  FROM employees
 WHERE job_id IN (SELECT job_id
                    FROM jobs
                   WHERE max_salary <= 10000)
ORDER BY first_name , last_name;

```

子查询获取了所有最高薪水小于等于 10000 的职位列表，然后外查询使用`IN`运算符返回属于这些职位的员工信息。如果使用`NOT IN`运算符，则返回不属于这些职位的员工信息。

### 关联子查询

关联子查询会引用外部查询中的列，因而与外部查询产生关联。关联子查询对于外查询中的每一行都会运行一次（数据库可能会对此进行优化），而非关联子查询在整个查询运行时只会执行一次。

```sql
SELECT job_id,
       first_name,
       last_name,
       salary
  FROM employees o
 WHERE salary = (SELECT MAX(salary)
                   FROM employees i
                  WHERE i.job_id = o.job_id)
 ORDER BY job_id, first_name;

```

子查询的`WHERE`子句中使用了外查询的 job_id 字段作为判断条件，因此外查询先检索出所有的 employees 数据，针对每一行数据，将 job_id 传递给子查询；子查询获取每个职位的最高薪水，然后再根据薪水值对外部的数据行进行过滤；直到外查询中的所有行都被处理完成。

除了`WHERE`子句外，`SELECT`列表中也可以使用关联子查询：

```sql
SELECT d.department_name,
       (SELECT SUM(salary)
          FROM employees e
         WHERE e.department_id = d.department_id) AS sum_salary
  FROM departments d
  ORDER BY d.department_name;

```





## 比较运算符

使用比较符是其中一类子查询

比较运算符包括 =、!=、<>、<=> 、>、<、>=、<=

## 逻辑条件

**AND** 

```sql
SELECT first_name,
		last_name,
		salary
	FROM employees
   WHERE job_id = 'IT_PROG'
     AND salary > 5000;
		
```

`AND`运算符指定了两个条件，只有当它们都为真时，结果才为真；否则结果为假，不返回结果。





**OR**

与`AND`类似的还有`OR`运算符，它也可以组合多个查询条件；但是`OR`只要有一个条件为真，结果就为真。

```sql
SELECT first_name,
		last_name,
		job_id,
		salary
	FROM employees
   WHERE job_id = 'AD_PRES'
     OR job_id = 'AD_VP';
```

对于逻辑运算符`AND`和`OR`，SQL使用短路运算，也就是说，只要前面的表达式能够决定最终的结果，不进行后面的计算。这样能够提高运算效率。因此，以下条件不会产生除零错误：

```sql
1 = 0 AND 1/0 = 1;
1 = 1 OR 1/0 = 1;
```

通过结合运算符`AND`和`OR`，可以构造更加复杂的查询条件。假设我们想要查询 job_id 等于 “IT_PROG” 或者 “SA_REP”，并且薪水大于 10000 的员工信息：

```sql
SELECT first_name,
		last_name,
		job_id,
		salary
	FROM employees
	WHERE job_id = 'IT_PROG'
		OR job_id = 'SA_REP'
		AND salary > 10000;
```

**NOT**

除了`AND`和`OR`之外，`NOT`运算符用于取反操作，它的逻辑真值表如下：

|       |  NOT  |
| :---: | :---: |
| TRUE  | FALSE |
| FALSE | TRUE  |
| NULL  | NULL  |

除此之外，`NOT`还可以结合前面介绍的运算符一起使用：

- `NOT BETWEEN`，位于范围之外
- `NOT IN`，不在列表之中
- `NOT LIKE`，不匹配模式
- `NOT EXISTS`，子查询不存在结果
- `NOT IS NULL`，不为空，等价于`IS NOT NULL`



## 修饰关键字

修饰关键字包括 ANY、SOME、ALL 三个，如果子查询返回多个值时，可以使用它们

> operand comparison_operator  ANY（子查询）
> operand comparison_operator  SOME（子查询）
> operand comparison_operator  ALL（子查询

|        |  ANY   |  SOME  |  ALL   |
| :----: | :----: | :----: | :----: |
| > ,>=  | 最小值 | 最小值 | 最大值 |
| <, <=  | 最大值 | 最大值 | 最小值 |
|   =    | 任意值 | 任意值 |        |
| <>, != |        |        | 任意值 |

### 处理情况

1. 运算符为 >或 >=，使用 ANY 关键字时，表示大于子查询结果中的最小值

2. 运算符为 > 或 >=，使用 ALL 关键字时，表示大于子查询结果中的最大值

3. 运算符为 < 或 <=，使用 ANY 或 SOME 关键字时，表示小于子查询结果中的最大值；使用ALL关键字时，表示小于子查询结果中的最小值

4. 运算符为=，使用ANY或SOME关键字时，表示等于子查询结果中的任意值；使用ALL关键字时，则返回空



### [NOT] IN

第二种子查询是由IN 或 NOT IN引发的子查询，与比较运算符使用的方法基本相同 

> 其中，= ANY 运算符与 IN 等效，!= ALL或 <> ALL运算符与 NOT IN 等效



### [NOT] EXISTS

第三种子查询是由 `EXISTS` 或  `NOT EXISTS` 引发的子查询。如果子查询返回任何行，`EXISTS` 将返回 TRUE；否则返回 FALSE





## 存储查询结果

可以把查询结果统一存储到一个新的数据表中，而不需要一条一条地录入

创建一个新的表

```sql
CREATE TABLE IF NOT EXISTS tdb(
    cate_id SMALLINT PRIMARY KEY AUTO_INCREMENT,
    cate_name VARCHAR(20) NOT NULL
);
```

查询表中的所有记录，并按 ’ 类别 ‘ 进行分组

```sql
SELECT good_cate FROM tdb GROUP BY good_cate;
```

将分组结果写入到 “商品分类” 数据表中。

> 
> INSERT [INTO] tbl_name [(col_name),...)] SELECT...;
> 



```sql
INSERT tdb(cate_name) SELECT good_cate FROM tdb_goods GROUP BY good_cate;
```

<a href= "cnblogs.com/xiaohuochai/p/6077677.html" blank=""> 子查询</a> 
























































































参考：

<https://www.cnblogs.com/xiaohuochai/p/6081482.html>