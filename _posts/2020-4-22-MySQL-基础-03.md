---
layout: post
title:  MySQL 基础 03
date:   2020-4-22
categories: MySQL
tags:  MySQL
---
* content
{:toc}
## 函数

mysql 数据库中的函数根据功能可以划分为字符函数、数值运算符与函数、比较运算符与函数、日期时间函数、信息函数、聚合函数、加密函数以及自定义函数等。

### 字符串函数

|  函数名称   |           描述           |
| :---------: | :----------------------: |
|  CONCAT()   |         字符链接         |
| CONCAT_WS() | 使用指定的分隔符链接字符 |
|  FORMAT()   |        数字格式化        |
|   LOWER()   |      转换成小写字母      |
|   UPPER()   |      转换成大写字母      |
|   LEFT()    |       获取左侧字符       |
|   RIGHT()   |       获取右侧字符       |

<br />

|     名称     |        描述        |
| :----------: | :----------------: |
|   LENGTH()   |   获取字符串长度   |
|   LTRIM()    |    删除前导空格    |
|   RTRIM()    |    删除后续空格    |
|    TRIM()    | 删除前导和后续空格 |
| SUBSTRING()  |     字符串截取     |
| [NOT] LIKE() |      模式匹配      |
|  REPLACE()   |     字符串替换     |

**CONCAT()** 用于字符连接

```sql
SELECT CONCAT('a', 'b');

SELECT CONCAT('a', '-', 'b');
```

CONCAT() 函数也可用于将一个数据表中的两个字段的所有记录进行字符连接

```sql
SELECT CONCAT(username, age) AS full FROM test;
```



**CONCAT_WS()**

使用指定的分隔符进行字符连接，该函数的第一个参数是指定分隔符

```sql
SELECT CONCAT_WS('|', '1', '2', '3');
```

结果：

1 | 2 |3

**FORMAT()**

主要用于数字格式化，最终返回一个字符型数字。第一个参数为待格式化的数字，第二个参数为要保留的小数位数　

```sql
SELECT FORMAT(12345.44677, 2);
```





**REPLACE()** 

用于字符串的替换

```sql
SELECT REPLACE ('MySQL', 'L', '-');
```

将字符 ‘L’ 替换为 ‘-’

**SUBSTRING()**

用于字符串截取，第一个参数是开始截取的起始位置，第二个参数是截取的字符数目, 如果省略第二个参数，则一直截取到字符串的结尾

> [注意]这里是从1开始计数的，而不是从0开始的

**[NOT] LIKE**

用于模式匹配，其中 

- `% `代表 0 个或多个字符，
- `_` 代表任意 1 个字符。返回 1 表示匹配，0 表示不匹配

如果要匹配通配符（% 或 _ ）自身，可以在它们前面加上一个反斜杠（\）进行转义。

![](https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426104332.png)



### 数学运算符

|    名称    |   描述    |
| :--------: | :-------: |
|   CEIL()   | 进 1 取整 |
|   DIV()    | 整数除法  |
|  FLOOR()   | 舍 1 取整 |
|   MOD()    |  取余数   |
|  POWER()   |  幂运算   |
|  ROUND()   | 四舍五入  |
| TRUNCATE() | 数字截取  |

<br />

**CEIL()** 函数主要用于进一取整(向上取整)

```sql
SELECT CEIL(3.1);
```

结果为 4

**FLOOR()** 函数主要用于舍一取整(向下取整)

```sql
SELECT FLOOR(3.9);
```

结果为 3

**ROUND()** 函数主要用于四舍五入，两个参数分别为浮点数和保留的小数位数, 默认只保留整数部分

```sql
SELECT ROUND(3.36);

SELECT ROUND(3.36, 1);
```



**DIV()** 主要用于整数的除法

```sql
SELECT 7 DIV 2;
```

**MOD()** 主要用于取余数 等同于 % 可以是整数，也可以是小数。

```sql
SELECT 5 % 3;

SELECT 5 MOD 3;
```



**POWER()** 主要用于幂运算

```sql
SELECT POWER(3,2);
```

**TRUNCATE()** 主要用于数字截取，两个参数分别为数值和截断到小数点后 n 位 。

```sql
SELECT TRUNCATE(33.33, 1);

SELECT TRUNCATE(33.33, 0);
```



### 比较运算符

| 名称                      | 描述                  |
| :------------------------ | :-------------------- |
| [NOT] BETWEEN ... AND ... | [不] 在范围之内       |
| [NO] IN()                 | [不] 在列出值范围之内 |
| IS [NOT] NULL             | [不] 为空             |

<br />

**[NOT] BETWEEN ... AND ...**

```sql
SELECT 10 BETWEEN 5 AND 20;
```

**[NO] IN()**

```sql
SELECT 10 IN (5, 10, 15,20);
```

**IS [NOT] NULL**

```sql
SELECT 0 IS NULL;
```

### 时间日期

|     名称      |      描述      |
| :-----------: | :------------: |
|     NOW()     | 当前日期和时间 |
|   CURDATE()   |    当前日期    |
|   CURTIME()   |    当前时间    |
|  DATE_ADD()   |    日期变换    |
|  DATEDIFF()   |    日期差值    |
| DATE_FORMAT() |   日期格式化   |

**NOW()** 返回当前日期和时间

```sql
SELECT NOW();
```

**CURDATE()** 返回当前日期

```sql
SELECT CURDATE();
```

**CURTIME()** 返回当前时间

```sql
SELECT CURTIME();
```

**DATE_ADD()** 函数日期变化，可以增加，也可以减少

```sql
SELECT DATE_ADD('2016-11-19',INTERVAL 365 DAY);

SELECT DATE_ADD('2016-11-19',INTERVAL -365 DAY);

SELECT DATE_ADD('2016-11-19',INTERVAL 1 YEAR);
```

**DATEDIFF()** 函数日期差值，两个日期的差值

```sql
SELECT DATEDIFF('2016-11-19', '2015-11-19');
```

返回值为 DAY

**DATE_FORMAT()** 函数进行日期格式化

```sql
SELECT DATE_FORMAT('2016-11-19', '%m/%d/%Y');
```

### 信息函数

|       名称        |         描述         |
| :---------------: | :------------------: |
| CONNECTION_ID（） |       连接 ID        |
|    DATABASE()     |      当前数据库      |
| LAST_INSERT_ID()  | 最后插入记录的 ID 号 |
|      USER()       |       当前用户       |
|     VERSION()     |       版本信息       |

<br />

**CONNECTION_ID()**  返回连接 ID (线程 ID)

```sql
SELECT CONNECTION_ID();
```

**DATABASE()** 返回当前数据库名称

```sql
SELECT DATABASE();
```

**LAST_INSERT_ID()** 返回最后插入记录的ID，当一次性写入多条记录时，函数返回的ID为第一条记录的ID

```sql
SELECT LASR_INSERT_ID();
```

**USER()** 返回当前用户

**VERSION()** 返回版本信息

```sql
SELECT USER();

SELECT VERSION();
```



### 聚合函数

| 名称    | 描述   |
| ------- | ------ |
| AVG()   | 平均值 |
| COUNT() | 计数   |
| MAX()   | 最大值 |
| MIN()   | 最小值 |
| SUM()   | 求和   |

聚合函数只能用于数据表，不能用于单个数值的计算

```sql
SELECT AVG(1, 2, 3)
```

关于聚合函数，需要注意两点：

- 在参数中使用`DISTINCT`，可以在计算之前排除组内的重复值；
- 聚合函数在计算时，忽略输入为 NULL 值的行。

### 加密函数

|    名称    |     描述     |
| :--------: | :----------: |
|   MD5()    | 信息摘要算法 |
| PASSWORD() |   密码算法   |

**MD5()** 

**PASSWORD()**   密码算法，通过PASSWORD()修改当前用户和其他用户的密码，修改客户端自己的密码

```sql
SELECT PASSWORD('MySQL');
```



### 自定义函数

函数可以返回任意类型的值，同样可以接收这些类型的参数。函数参数和返回值之前没有必然的联系

[注意]一个函数最多可以有1024个参数

用户自定义函数 (user-defined function, UDF) 是一种对 MySQL 扩展的途径，其用法与内置函数相同

自定义函数的两个必要条件：**1、参数；2、返回值**

#### 创建自定义函数

```sql
CREATE FUNCTION function_name
RETURNS
{STRING|INTEGER|REAL|DECIMAL}
routine_body
```

关于自定义函数的函数体

1. 函数体可以由合法的 SQL 语句构成；

2. 函数体可以是简单的 SELECT 或 INSERT 语句；

3. 函数体如果为复合结构则使用 BEGIN...END 语句；

4. 复合结构可以包含声明、循环、控制结构。



#### 创建不带参数的自定义函数

```sql
CREATE FUNCTION f1() RETURNS VARCHAR(30)
RETURN DATE_FORMAT(NOW(), '%Y年%m月%d日 %H点:%i分:%s秒');

SELECT f1();
```

#### **创建带参数的自定义函数**

```sql
CREATE FUNCTION f2(num1 SMALLINT UNSIGNED,num2 SMALLINT UNSIGNED) 
RETURNS FLOAT(10,2) UNSIGNED 
RETURN  (num1+num2)/2;

SELECT f2(2,6)
```

[注意]如果自定义函数存在符合结构的多个语句，函数体要包含在BEGIN...END内，同时，需要通过DELIMITER将默认的结束符 ; 修改成其他符号，如：//  $$  ，以免函数由于语句结尾的 ; 号导致中断

### 删除函数

```
DROP FUNCTION [IF EXISTS] function_name
```



## **多表连接查询**

在实际应用中，常常需要从两个或更多的表中同时返回相关联的信息。

例如，我们在查询员工信息时，只能看到他/她所在的部门编号，如果想要同时显示部门的名称，就需要连接 employees 表和 departments 表中的信息。

```sql
SELECT departments.department_id, 
       employees.department_id,
       department_name,
       employees.first_name,
       employees.last_name
  FROM employees
 INNER JOIN departments
    ON employees.department_id = departments.department_id;
```

首先，引入了新的关键字：`INNER JOIN`和`ON`。`INNER JOIN`表示内连接，这里表示要连接 employees 表和 departments 表；`ON`用于指定连接条件，这里表示 employees 中的部门编号等于 departments 的部门编号。


对于内连接，只有满足连接条件的行才会被返回。

另外，我们在`SELECT`列表中的某些字段名之前加上了表名限定，例如 departments.department_id，这是因为两个表中都存在部门编号，必须明确指定需要显示哪个表中的信息。但是，如果某个字段只存在一个表中，可以省略表名，例如 department_name。

为了便于了解字段的来源，建议总是加上表名限定。但是如果总是写上表的全名，输入时非常麻烦，也不便于阅读，因此我们引入了表的别名。

### 使用表别名

修改一下上面的示例，加上表别名：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
  FROM employees AS e
 INNER JOIN departments AS d
    ON e.department_id = d.department_id;

```

通过在表名后面加上关键字`AS`，我们为 employees 表指定了别名 e，为 departments 表指定了别名 d。然后在查询的其他地方使用了表别名。

### 连接类型

SQL 中的连接主要包括以下类型：

- INNER JOIN，内连接
- LEFT OUTER JOIN，左外连接
- RIGHT OUTER JOIN，右外连接
- FULL OUTER JOIN，全外连接
- CROSS JOIN，交叉连接
- NATURAL JOIN，自然连接
- Self Join，自连接

其中，左外连接、右外连接以及全外连接统称为外连接（OUTER JOIN）。

### 内连接

内连接使用关键字`INNER JOIN`表示，也可以简写成`JOIN`； 内连接只返回两个表中匹配的数据行。参考以下示意图（基于两个表的 id 进行连接）：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426213910.png"/>

其中，id = 1 和 id = 3 是两个表中匹配的数据，因此内连接返回了 2 行记录。



### 左外连接

左外连接使用关键字`LEFT OUTER JOIN`表示，也可以简写成`LEFT JOIN`； 左外连接返回左表中所有的数据行；对于右表中的数据，如果没有匹配的值，返回空值。参考以下示意图（基于两个表的 id 进行连接）：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426215634.png"/>

其中，id = 2 在 table1 中存在，在 table2 中不存在；左外连接仍然会返回该记录，只是对于 table2 中的列，返回的是空值。

假如我们想要查看部门和其员工信息，考虑到某些部门可能还没有员工，如果使用内连接，无法显示这些部门，因此使用左外连接：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
  FROM departments d
  LEFT JOIN employees e
    ON e.department_id = d.department_id
 WHERE d.department_id IN (110, 120, 130);
```

### 右外连接

右外连接使用关键字`RIGHT OUTER JOIN`表示，也可以简写成`RIGHT JOIN`； 右外连接返回右表中所有的数据行；对于左表中的数据，如果没有匹配的值，返回空值。参考以下示意图（基于两个表的 id 进行连接）：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426215910.png"/>

也就是说：

```sql
table1 RIGHT JOIN table2
```

等价于

```sql
table2 LEFT JOIN table1
```

假如我们想要查看部门和其员工信息。考虑到某些员工可能还没有分配部门，如果使用内连接，无法显示这些员工；因此使用右外连接：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
  FROM departments d
 RIGHT JOIN employees e
    ON d.department_id = e.department_id
 WHERE e.employee_id IN (176, 177, 178);

```



### 全外连接

全外连接使用关键字`FULL OUTER JOIN`表示，也可以简写成`FULL JOIN`。

全外连接等效于左外连接加上右外连接，返回左表和右表中所有的数据行。参考以下示意图（基于两个表的 id 进行连接）：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427073319.png"/>

需要注意的是，对于重复的行（id = 1 和 id = 3），只返回一次记录。

假如我们想要查看部门和其员工信息，需要同时考虑到某些部门可能还没有员工，而且某些员工可能还没有分配部门，使用全外连接：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
     FROM departmrnt d
     FULL JION employees e
       ON d.department_id = e.department_id
     WHERE e.employee_id IN (176, 177, 178)
     	OR d.department_id IN (110, 120, 130);
```

对于内连接和外连接，如果满足以下条件，可以使用`USING`替代`ON`，简化连接条件的输入：

- 连接条件是等值连接，即 t1.col1 = t2.col1
- 两个表中的列必须同名同类型，即 t1.col1 = t2.col1

内连接查询示例，由于 employees 表和 departments 表中的 department_id 字段名称和类型都相同，可以使用`USING`简写成以下语句：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
  FROM employees e
 INNER JOIN departments d
 USING (department_id);

```

多表连接的示例。

```sql
SELECT d.ddepartment_name,
	   e.first_name,
	   e.last_name,
	   j.job_title
	FROM department d
  INNER JOIN employee e ON d.department_id = e.department_id
  INNER JION jobs j    ON j.job_id = e.job_id
```

对于多个表的连接，按照出现的顺序进行连接；如有必要，可以使用括号 () 修改连接的顺序：

```sql
SELECT d.department_name,
       e.first_name,
       e.last_name,
       j.job_title
  FROM departments d
 INNER JOIN (employees e
       INNER JOIN jobs j
          ON j.job_id = e.job_id)
    ON d.department_id = e.department_id;

```



## SQL 查询执行顺序

示例

```sql
SELECT DISTINCT t1.column1 AS alias1, t2.col2, aggregate_function(column3)
  FROM table1 t1
  JOIN table2 t1 ON t1.column1 = t2.column1
 WHERE conditions
 GROUP BY t1.column1, t2.col2
HAVING group_condition
 ORDER BY t1.column1 ASC, t2.col2 DESC
OFFSET m ROWS
 FETCH NEXT num_rows ROWS ONLY;

```

以上就是 SQL 语法中常见的各个子句（当然不是全部子句）的书写顺序，但是它们的逻辑执行顺序却与此不同：

1. 首先，`FROM`和`JOIN`是SQL执行的第一步，它们从逻辑上决定了接下来要操作的数据集；

2. 其次，执行`WHERE`子句，对上一步的数据集进行过滤，保留满足条件的行；需要注意的是，此时还没有执行`SELECT`子句，`WHERE`条件中不能引用`SELECT`列表中的列别名（alias1）或者聚合函数
3. 接下来，基于`GROUP BY`子句指定的表达式进行分组，分组条件有多少不同的取值，操作后的结果就有多少行；
4. 然后，基于分组结果执行聚合函数 aggregate_function，对于每个分组取值，生成一个函数结果；如果没有分组子句，基于所有结果执行一次聚合操作；
5. 如果查询中使用了`GROUP BY`，可以使用`HAVING`针对分组后的结果进一步进行过滤，通常是利用聚合函数的值进行过滤，如果是其他过滤条件，可以在`WHERE`子句中提前指定，避免无谓的操作；
6. 接下来，`SELECT`子句可以选择要显示的列。如果存在`GROUP BY`子句，`SELECT`列表只能引用分组所使用的列，或者聚合函数；如果不存在`GROUP BY`子句，可以引用`FROM`和`JOIN`指定的表中的任何列；
7. 如果在`SELECT`之后指定了`DISTINCT`关键字，需要针对上一步的结果集进行去重操作，过滤掉所有重复的值；
8. 应用`ORDER BY`子句对上一步的结果进行最终的排序操作。如果存在`GROUP BY`子句或者`DISTINCT`关键字，只能使用`SELECT`列表中出现的字段进行排序；如果不存在`GROUP BY`子句和`DISTINCT`，可以使用`FROM`和`JOIN`指定的表中的任何列；
9. 最后，`OFFSET`和`FETCH`（或者`LIMIT`、`TOP`）限定了返回的行。



## SQL 中的条件表达式

SQL 是一种声明性的语言，它没有提供其他编程语言中的条件语句（if-then-else 或者 switch）。但是，SQL 支持 CASE 表达式，可以基于一个条件列表返回不同的结果值，它更像是一种支持嵌套的三元表达式（? :）。

CASE 表达式支持两种形式：简单 CASE 表达式和搜索 CASE 表达式。另外，还存在一些简写形式的 CASE 函数，以及不同数据库产品特有的扩展。


### 简单 CASE 表达式

简单 CASE 表达式的语法如下：

```sql
CASE expression
  WHEN expression_1 THEN result_1
  WHEN expression_2 THEN result_2
  ...
  [ELSE default_result]
END

```

简单 CASE 表达式比较`CASE`后的表达式与`WHEN`列表中的表达式的值，找到第一个匹配的值（=），返回后面相应的结果；如果没有匹配值，返回`ELSE`子句的值；如果此时没有指定`ELSE`子句，返回空值。

示例

```sql
SELECT e.first_name,
       e.last_name,
       e.job_id,
       CASE e.job_id
         WHEN 'AD_PRES' THEN 'President'
         WHEN 'AD_VP'   THEN 'Administration Vice President'
         WHEN 'IT_PROG' THEN 'Programmer'
         ELSE 'Other job'
       END
  FROM employees e;

```

简单 CASE 表达式仅仅比较两个值是否相等，然后返回相应的值。如果我们想要基于更加复杂的条件进行判断，例如某个值是否为空，某个值是否大于指定的数值，甚至使用子查询的结果进行判断，都需要使用更加强大的搜索 CASE 表达式。

### 搜索 CASE 表达式

搜索 CASE 表达式的语法如下：

```sql
CASE
  WHEN condition_1 THEN result_1
  WHEN condition_2 THEN result_1
  ...
  [ELSE default_result]
END

```

表达式按照顺序计算`WHEN`子句中的条件，找到第一个结果为 True 的分支，返回相应的结果；如果没有任何条件为真，返回`ELSE`中的默认值；如果此时没有指定`ELSE`子句，返回空值。

```sql
SELECT e.first_name,
       e.last_name,
       e.salary,
       CASE
         WHEN e.salary < 5000  THEN 'Low'
         WHEN e.salary < 10000 THEN 'Middle'
         WHEN e.salary < 15000 THEN 'High'
         ELSE 'Top'
       END AS salary_level
  FROM employees e;

```

CASE 表达式除了可以用于`SELECT`列表，也可以出现在其他 SQL 子句中，例如`WHERE`条件、`GROUP BY`分组、`ORDER BY`排序等。

```sql
SELECT CASE
         WHEN e.salary < 5000  THEN 'Low'
         WHEN e.salary < 10000 THEN 'Middle'
         WHEN e.salary < 15000 THEN 'High'
         ELSE 'Top'
       END AS salary_level,
       MIN(e.salary) min_salary,
       MAX(e.salary) max_salary
  FROM employees e
 GROUP BY CASE
            WHEN e.salary < 5000  THEN 'Low'
            WHEN e.salary < 10000 THEN 'Middle'
            WHEN e.salary < 15000 THEN 'High'
            ELSE 'Top'
          END;

```

### 缩写 CASE 表达式

除了以上两种形式的 CASE 表达式之外，SQL 还定义了两个与 NULL 值相关的缩写 CASE 表达式（函数）：nullif 和 coalesce。

NULLIF 函数需要2个参数，如果第一个参数等于第二个参数，返回 NULL 值；否则，返回第一个参数的值：

```sql
NULLIF(expression_1, expression_2)
```

它的等价 CASE 表达式如下：

```sql
CASE
  WHEN expression_1 = expression_2 THEN NULL
  ELSE expression_1
END

```

NULLIF 函数的一个常见用途是防止除零错误：

```sql
value1 / NULLIF(value2 , 0)

```

COALESCE 函数接受一个参数列表，并且返回第一个非空的参数值；如果所有参数都为空，返回空值：

```sql
COALESCE(expression_1, expression_2, expression_3, ...)

```

它的等价 CASE 表达式如下：

```sql
CASE
WHEN expression_1 IS NOT NULL THEN expression_1
WHEN expression_2 IS NOT NULL THEN expression_2
WHEN expression_3 IS NOT NULL THEN expression_3
...
END

```

示例：

```sql
SELECT e.first_name,
       e.last_name,
       COALESCE(e.commission_pct, 0)
  FROM employees e;

```

如果员工存在佣金百分比，返回该值；否则，显示为 0。

### 扩展函数

MySQL 提供了 IF 函数：

```sql
IF(expr1, expr2, expr3)

```

它接受三个参数。如果第一个参数为真（expr1 <> 0 并且 expr1 不为空），返回第二个参数的值；否则，返回第三个参数的值。

```sql
-- For MySQL only
SELECT IF(1<2, '1<2', '1>=2'), IF(NULL, 'Y', 'N');
-- result is: 1<2        N

```

`IFNULL(expr1, expr2)`函数。它接受两个参数，如果 expr1 不为空，返回 expr1 的值；否则，返回 expr2 的值。

```sql
SELECT e.first_name,
       e.last_name,
       IFNULL(e.commission_pct, 0)
  FROM employees e;

```



## 集合运算

SQL:2016（ISO/IEC 9075:2016）标准中定义的集合操作符（`UNION`、`INTERSECT`和`EXCEPT`）

SQL 基于关系代数；因此 ，SQL 中的表或查询结果与集合理论中的集合非常类似，表或查询结果中的行相当于集合中的元素。不过，它们之间也存在一些不同之处：

- 集合理论中的集合不允许存在重复的数据，但是 SQL 允许。因此，SQL 中的集合也被称为多重集合（multiset）；
- 多重集合与集合理论中的集合都是无序的，但是 SQL 查询结果可以通过ORDER BY子句进行排序。

SQL 中的集合操作符要求参与运算的表或查询结果具有相同数量的列，以及对应列的类型必须匹配或兼容。

### 并集（UNION）

`UNION`操作符用于将两个查询结果合并成一个结果集，包含了第一个查询结果以及第二个查询结果中的数据：

```sql
SELECT column1, column2
  FROM table1 
 UNION [DISTINCT | ALL]
SELECT col1, col2
  FROM table2;

```

其中，DISTINCT 表示将合并后的结果集进行去重；ALL 表示保留结果集中的重复记录；如果省略，默认为 DISTINCT。

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427104600.png"/>

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427104623.png"/>

示例：

```sql
SELECT d.department_id
  FROM departments d
 UNION 
SELECT e.department_id
  FROM employees e;

```

首选，分别执行两个查询，获取 departments 表中的部门编号和 employees 表中的部门编号；然后将它们进行合并操作，并且排除重复的记录。

以下语句执行了类似的操作，只是不进行重复值的删除：

```sql
SELECT d.department_id
  FROM departments d
 UNION ALL
SELECT e.department_id
  FROM employees e;

```

如果要对集合运算后的数据进行排序，需要将`ORDER BY`子句写在最后；`UNION`之前的查询中不能出现排序操作：

```sql
SELECT d.department_id
  FROM departments d
 UNION
SELECT e.department_id
  FROM employees e
 ORDER BY department_id;

```

对于分组操作，每个 SELECT 查询都可以包含一个`GROUP BY`，但是它们只针对各自进行分组；如果想要对最终结果进行分组，需要在外层增加一个 SELECT 语句：

```sql
SELECT tmp.department_id
  FROM (SELECT d.department_id
          FROM departments d
         UNION
        SELECT e.department_id
          FROM employees e) tmp
 GROUP BY tmp.department_id;

```

### 交集（INTERSECT）

`INTERSECT`操作符用于返回两个查询结果中的共同部分，即同时出现在第一个查询结果和第二个查询结果中的数据：

```sql
SELECT column1, column2
  FROM table1 
INTERSECT [DISTINCT | ALL]
SELECT col1, col2
  FROM table2;

```

其中，DISTINCT 表示将最终的结果集进行去重；ALL 表示保留结果集中的重复记录；如果省略，默认为 DISTINCT。参考以下示意图：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427110404.png"/>

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427110432.png"/>

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427110452.png"/>

注意中间的示意图，虽然 result1 中包含两个 1，但是最终结果只有一个 1；因为 result2 中的 1 只能和 result1 中的一个 1 匹配。

> MySQL 不支持`INTERSECT`操作符；

以下示例使用`INTERSECT`获取所有经理的员工编号：

```sql
SELECT m.employee_id
  FROM employees m
INTERSECT
SELECT e.manager_id
  FROM employees e
 ORDER BY employee_id;

```

对于 MySQL，以上示例可以通过`JOIN`实现：

```sql
SELECT DISTINCT
       m.employee_id
  FROM employees m
  JOIN employees e
    ON (m.employee_id = e.manager_id)
 ORDER BY employee_id;

```

### 差集（EXCEPT）

`EXCEPT`操作符用于返回出现在第一个查询结果中，但不在第二个查询结果中的数据：

```sql
SELECT column1, column2
  FROM table1 
EXCEPT [DISTINCT | ALL]
SELECT col1, col2
  FROM table2;

```

其中，DISTINCT 表示将最终的结果集进行去重；ALL 表示保留结果集中的重复记录；如果省略，默认为 DISTINCT。

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427111536.png"/>

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427111557.png"/>

> MySQL 不支持`EXCEPT`操作符；

