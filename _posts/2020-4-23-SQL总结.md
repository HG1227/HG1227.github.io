---
layout: post
title:  SQL 总结
date:   2020-4-23
categories: MySQL
tags:  MySQL
---
* content
{:toc}
SQL 提供了多种对数据进行过滤的方式，包括`WHERE`、`HAVING`以及`ON`子句等。虽然它们都能够实现类似的功能，但是你知道它们之间的区别吗？





# WHERE 和 HAVING、ON 有什么区别？



## WHERE 与 HAVING



`WHERE`与`HAVING`的根本区别在于：

- `WHERE`子句在`GROUP BY`分组和聚合函数**之前**对数据行进行过滤；
- `HAVING`子句对`GROUP BY`分组和聚合函数**之后**的数据行进行过滤。

因此，`WHERE`子句中不能使用聚合函数。



## WHERE 与 ON

当查询涉及多个表的关联时，我们既可以使用`WHERE`子句也可以使用`ON`子句指定连接条件和过滤条件。这两者之间的主要区别在于：

- 对于内连接（inner join）查询，`WHERE`和`ON`中的过滤条件等效；
- 对于外连接（outer join）查询，`ON`中的过滤条件在连接操作之前执行，`WHERE`中的过滤条件（逻辑上）在连接操作之后执行。

对于内连接查询而言，以下三个语句的结果相同：

```mysql
-- 语句 1
select d.dept_name, e.emp_name, e.sex, e.salary 
from employee e, department d
where e.dept_id = d.dept_id
and e.emp_id = 10;
dept_name|emp_name|sex|salary |
---------|--------|---|-------|
研发部   |廖化    |男  |6500.00|

-- 语句 2
select d.dept_name, e.emp_name, e.sex, e.salary 
from employee e
join department d on (e.dept_id = d.dept_id and e.emp_id = 10);
dept_name|emp_name|sex|salary |
---------|--------|---|-------|
研发部   |廖化    |男  |6500.00|

-- 语句 3
select d.dept_name, e.emp_name, e.sex, e.salary 
from employee e
join department d on (e.dept_id = d.dept_id)
where e.emp_id = 10;
dept_name|emp_name|sex|salary |
---------|--------|---|-------|
研发部   |廖化    |男  |6500.00|

```

语句 1 在`WHERE`中指定连接条件和过滤条件；语句 2 在`ON`中指定连接条件和过滤条件；语句 3 在`ON`中指定连接条件，在`WHERE`中指定其他过滤条件。

尽管如此，仍然建议将两个表的连接条件放在`ON`子句中，将其他过滤条件放在`WHERE`子句中；这样语义更加明确，更容易阅读和理解。对于上面的示例而言，推荐使用语句 3 的写法。

对于外连接而言，连接条件只能用`ON`子句表示，因为`WHERE`子句无法表示外连接的语义。



# 数据库自增字段的实现方式

## AUTO_INCREMENT

MySQL 通过 `AUTO_INCREMENT` 属性定义自增字段，并且需要遵循以下规则：

- 每个表只能有一个自增字段，数据类型一般是整数；
- 自增字段必须创建主键（`PRIMARY KEY`）或者唯一索引（`UNIQUE`）；
- 自增字段必须非空（`NOT NULL`），MySQL 会自动为自增字段设置非空约束。

以下语句创建了一个表 users，其中 user_id 是一个自增主键字段：

```mysql
create table users(
  user_id INT AUTO_INCREMENT PRIMARY KEY,
  user_name VARCHAR(50) NOT NULL,
  email VARCHAR(100)
);

```

插入两条数据：

```mysql
insert into users(user_name, email) values ('u1', 'u1@test.com');
insert into users(user_name, email) values ('u2', 'u2@test.com');

select * from users;
user_id|user_name|email      |
-------|---------|-----------|
      1|u1       |u1@test.com|
      2|u2       |u2@test.com|

```

在上面的插入语句中，我们没有指定 user_id 的值，此时 MySQL 会自动为该字段生成一个递增序列值。AUTO_INCREMENT 字段的值默认从 1 开始，每次递增也是 1。

如果插入数据时为自增字段指定了 NULL 值或者 0，MySQL 同样会自动生成一个序列值。

```mysql
insert into users(user_id, user_name, email) values (null, 'u3', 'u3@test.com');
insert into users(user_id, user_name, email) values (0, 'u4', 'u4@test.com');

select * from users;
user_id|user_name|email      |
-------|---------|-----------|
      1|u1       |u1@test.com|
      2|u2       |u2@test.com|
      3|u3       |u3@test.com|
      4|u4       |u4@test.com|

```

如果插入数据时为自增字段指定了非空也非 0 的值，MySQL 会使用我们提供的值；而且还会将自增序列的起始值值设置为该值，可能导致自增字段值的跳跃。

```mysql
insert into users(user_id, user_name, email) values (100, 'u5', 'u5@test.com');
insert into users(user_name, email) values ('u6', 'u6@test.com');

select * from users;
user_id|user_name|email      |
-------|---------|-----------|
      1|u1       |u1@test.com|
      2|u2       |u2@test.com|
      3|u3       |u3@test.com|
      4|u4       |u4@test.com|
    100|u5       |u5@test.com|
    101|u6       |u6@test.com|

```

> MySQL 提供了 LAST_INSERT_ID 函数，用于获取最后一次生成的序列值。

另外，MySQL 也可以使用`ALTER TABLE`语句设置自增序列的值：

```mysql
ALTER TABLE users AUTO_INCREMENT = 200;
insert into users(user_name, email) values ('u7', 'u7@test.com');

select * from users where user_name = 'u7';
user_id|user_name|email      |
-------|---------|-----------|
    200|u7       |u7@test.com|

```

如果担心自增字段的值不够用，可以将 INT 类型改成 INT UNSIGNED，最大值可以到达 4294967295 (2^32 - 1); 还不够的话改成 BIGINT，最大值可以到达 9223372036854775807(2^63 - 1);