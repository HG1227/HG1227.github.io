---
layout: post
title:  成功搭建自己的博客 !
date:   2020-4-22
categories: MySQL
tags:  MySQL
---
* content
{:toc}








# 语法

## 关系数据库

关系数据库（Relational database）是指基于关系模型的数据库。关系模型由**关系数据结构（二维表）、关系操作集合、关系完整性约束**三部分组成。

常见的数据操作包括增加（Create）、查询（Retrieve）、更新（Update）以及删除（Delete），或者统称为增删改查（CRUD）。

为了维护数据的完整性和精确性，或者为了实现业务需求，SQL 标准定义了 6 种完整性约束。

- **非空约束**（NOT NULL），用于确保字段不会出现空值。例如学生信息表中，学生的姓名、出生日期、性别等一定要有数据。
- **唯一约束**（UNIQUE），用于确保字段中的值不会重复。例如每个学生的身份证、手机号等需要唯一。
- **主键约束**（Primary Key），用于唯一标识表中的每一行数据。例如学生信息表中，学号通常作为主键。主键字段不能为空并且唯一，每个表可以有且只能有一个主键。
- **外键约束**（Foreign Key），用于建立两个表之间的参照完整性。例如学生属于班级，学生信息表中的班级字段是一个外键，引用了班级表的主键。对于外键引用，被引用的数据必须存在，学生不可能属于一个不存在的班级。
- **检查约束**（CHECK）可以定义更多的业务规则。例如，性别的取值只能为“男”或“女”，用户名必须大写等；
- **默认值**（DEFAULT）用于为字段提供默认的数据。例如，玩家注册时的级别默认为 1 级。



## SQL 语句分类

常见的 SQL 语句包含以下类别：

- `DQL`（data query language），数据查询语言；主要是`SELECT`语句，用于查询数据库中的数据和信息。
- `DML`（data manipulation language），数据操作语言；主要用于对数据库进行数据的增加、修改和删除，包括`INSERT`、`UPDATE`、`DELETE`和`MERGE` 等语句。
- `DDL`（data definition language），数据定义语言；主要用于定义数据库中的模式对象，例如表或索引，包括`CREATE`、`ALTER`、`DROP`等等
- `TCL`（transaction control language），事务控制语言；用于管理数据库事务，主要包含`BEGIN TRANSACTION`、`COMMIT`、`ROLLBACK`、`SAVEPOINT`等语句。
- `DCL`（data control language），数据控制语言；用于控制数据的访问权限，主要有`GRANT`、`REVOKE`等语句。







## 数据类型

### 数据类型概述

关系型数据库中，用于存储数据的主要对象是表（table），表由行（row）和列（column）组成。

数据行，也称为记录（record）、元组（tuple），是二维表格中的行。表中的一行对应现实世界中的一个实体。

表中的每个列都拥有一个数据类型，数据类型定义了该列能够存储的数据值，以及允许执行的操作。常见的数据类型包括字符类型、数字类型、日期时间类型等。其中，数字类型可以进行加减乘除等数学运算，日期时间类型可以进行格式化显示。

SQL标准中定义的数据类型可以分为三类:

- 预定义数据类型（predefined data type）
- 构造数据类型（constructed data type）
- 自定义数据类型（user-defined data type）



### 预定义数据类型

- `CHARACTER`、`CHARACTER VARYING` 以及 `CHARACTER LARGE OBJECT` 统称为字符串类型，它们存储的值为字符串。
- `BINARY`、`BINARY VARYING` 以及 `BINARY LARGE OBJECT`统称为二进制串类型，它们存储的值为二进制串。
- `CHARACTER LARGE OBJECT` 以及 `BINARY LARGE OBJECT`统称为大对象串类型，它们存储的值为大对象串。
- `NUMERIC`、`DECIMAL`、`DECFLOAT`、`SMALLINT`、`INTEGER`以及BIGINT统称为精确数字类型。
- `FLOAT`、`REAL` 以及 `DOUBLE PRECISION`统称为近似数字类型。精确数字类型和近似数字类型统称为数字类型。
- `TIME WITHOUT TIME ZONE`以及` TIME WITH TIME ZONE` 统称为时间类型（不包含时区的时间和包含时区的时间）。
- TIMESTAMP WITHOUT TIME ZONE以及TIMESTAMP WITH TIME ZONE统称为时间戳类型（不包含时区的时间戳和包含时区的时间戳）。
- `DATE`、`TIME以及 `TIMESTAMP` 统称为日期时间类型，它们存储的值为日期时间。
- `INTERVAL` 称为时间间隔类型，存储的值为时间间隔。
- `DATALINK` 称为数据链接类型，用于访问存储在数据库之外的资源。
- `XML` 称为XML类型，存储的值为XML值。

#### 字符串类型

##### 定长字符串

SQL标准中关于固定长度字符串的定义如下：

```sql
CHARACTER [ ( n ) ]

--或者
CHAR [ ( n ) ]

```

其中，`CHARACTER`和`CHAR`是同义词，表示固定长度字符串；*n* 表示字符串的长度。

对于固定长度字符串，如果输入的字符串长度不够，将会使用空格进行填充。

> 在实际使用时，应该尽量避免使用定长字符串类型。

##### 变长字符串

变长字符串类型用于存储长度不固定的字符串，例如名字。SQL标准中关于可变长度字符串的定义如下：

```sql
VARCHAR [ ( n ) ]

-- 或者
CHAR VARYING [ ( n ) ]
```

其中，*n* 表示字符串的最大长度。

对于可变长度字符串，如果输入的字符串长度不够，存储实际的内容。

##### 数字类型

数字主要分为两类：精确数字，包括`NUMERIC`、`DECIMAL`、`DECFLOAT`、`SMALLINT`、`INTEGER`和`BIGINT`；以及近似数字，包括`FLOAT`、`REAL`和`DOUBLE PRECISION`。



##### 二进制类型

二进制类型分为定长二进制串`BINARY`、变长二进制串`BINARY VARYING`、二进制大对象`BINARY LARGE OBJECT`。

```sql
BINARY [ ( n ) ]


BINARY VARYING [ ( n ) ]
VARBINARY [ ( n ) ]


BINARY LARGE OBJECT [ ( n ) ]
BLOB [ ( n ) ]
```



##### 近似数字

近似数字也称为浮点型数字，主要用于科学计算。SQL标准中定义了3种浮点类型。

```sql
FLOAT [ ( p ) ]
REAL
DOUBLE PRECISION
```



##### 布尔类型

SQL标准使用三值布尔逻辑：`true`、`false`以及`unknown`。`unknown`使用`NULL`值表示。



##### 日期时间类型

与日期和时间相关的数据类型包括：`DATE`、`TIME`以及`TIMESTAMP`。

`DATE`存储年、月、日；`TIME`存储时、分、秒，以及秒的小数部分；`TIMESTAMP`同时包含年、月、日、时、分、秒，以及秒的小数部分。







## **登录退出**

　操作数据库的第一步是登录数据库，通常需要提供一个MySQL用户名和密码。如果服务器运行在登录服务器之外的其它机器上，还需要指定主机名

　　[注意]在退出数据库之后，cmd清空屏幕的操作是输入cls(相当于clear screen)



参数           描述
-D            (database)打开指定数据库
-h            (host)服务器名称
-p            (password)密码
-P            (port)端口号
-u            (user)用户名
-V            (version)输出版本信息并退出

## 语句规范

在操作数据库之前，要先了解数据库的语句规范，主要有以下三条

1. 关键字与函数名称全部大写

2. 数据库名称、表名称、字段名称全部小写

3. SQL语句必须以分号结尾

## 常用命令

mysql 数据库有以下三个常用命令:

- SELECT VERSION();         显示当前服务器版本 

- SELECT NOW();             显示当前日期时间 

- SELECT USER();            显示当前用户

## 数据库操作

### 创建数据库

关键字 ：`CREATE`

```python
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name 
      [DEFAULT] CHARACTER SET [=] charset_name
```

### **使用和切换当前数据库**

创建数据库并不表示选定并使用它，必须明确地操作，所以数据库操作的第二步是选择数据库

`USE db_name`
切换数据库 use db_name;  注意：进入到某个数据库后没办法再退回之前状态，但可以通过use进行切换 。



查看当前使用的数据库

 select database();



### **看下服务器下的数据库列表**

```python
SHOW {DATABASES | SCHEMAS} [LIKE 'pattern' | WHERE expr]
```



### **修改数据库**

```python
ALTER {DATABASE | SCHEMA} [db_name] [DEFAULT] CHARACTER SET [=] charset_name
```

(1) 增加列(字段)

```python
alter table tab_name add [column] 列名 类型［完整性约束条件］［first｜after 字段名］;

alter table user add addr varchar(20) not null unique first/after username;
```

**添加多个字段**

```python
alter table users2 
		add addr varchar(20),
		add age  int first,
		add birth varchar(20) after name;
```


(2) 修改一列类型

```python
alter table tab_name modify 列名 类型 [完整性约束条件]［first｜after 字段名］;

alter table users2 modify age tinyint default 20;
alter table users2 modify age int  after id;
```

(3) 修改列名

```python
alter table tab_name change [column] 列名 新列名 类型 [完整性约束条件]［first｜after 字段名］;
alter table users2 change age Age int default 28 first;
```











### **删除数据库的操作**

```python
DROP {DATABASE | SCHEMA} [IF EXISTS] db_name
```

drop database [if exists] db_name;

------



## 数据表操作

### 创建数据表

在 SQL 中，使用 `CREATE TABLE` 语句创建表：

下面在db1数据库中创建数据表tb1

> 
> CREATE  TABLE  [IF NOT EXISTS]  table_name(column_name data_type,...)
> 

```sql
CREATE TABLE table_name
(
  column_1 data_type column_constraint,
  column_2 data_type,
  ...,
  table_constraint
);

```

首先，需要指定一个新的表名 table_name；括号内是字段的定义，包括字段名、数据类型以及可选的约束，多个字段使用逗号进行分隔；最后还可以定义基于表的约束。

以下语句用于创建表 departments：

```sql
CREATE TABLE departments
    ( department_id    INTEGER NOT NULL PRIMARY KEY
    , department_name  CHARACTER VARYING(30) NOT NULL
    , manager_id       INTEGER
    , location_id      INTEGER
    ) ;

```







### **查看数据表**

> desc tab_name 查看表结构
> show columns from tab_name  查看表结构
> show tables 查看当前数据库中的所有的表
> 
> 
>SHOW TABLES [FROM db_name] [LIKE 'pattern' | WHERE expr]

### **查看数据表的列项**

> 
> SHOW COLUMNS FORM  tbl_name
> 



### **记录操作**

SQL 标准中提供了 3 种数据插入的方法：

1. `INSERT INTO … VALUES;`
2. `INSERT INTO … SELECT;`
3. `INSERT INTO … DEFAULT;`

#### 插入单条记录

记录操作的第一步是写入记录

　　在写入记录时，要注意的是，如果没有省略的字段，则按照参数顺序直接赋值即可；如果有省略的字段，则字段名和参数值都需要写出来

> 
> INSERT [INTO] tbl_name   [(col_name,...)]  VALUES(VAL,...)
> 

```python
insert into employee_new (id,name,birthday,salary) values
	(1,'yuan','1990-09-09',9000);


    -- 如果值列表与表中的字段顺序完全一致，可以省略字段列表
insert into employee_new values
	(2,'alex','1989-08-08',3000);

insert into employee_new (name,salary) values
	('xialv',1000);
```

#### **插入多条数据**

```python
insert into employee_new values
	(4,'alvin1','1993-04-20',3000),
	(5,'alvin2','1995-05-12',5000);
```

set 插入: insert ［into］ tab_name set 字段名=值

一次性只能插入一条记录

```python
insert into employee_new set id=12,name="alvin3";
```









#### **更新记录**

SQL 标准提供了 `UPDATE` 语句，用于更新表中的数据。基本语法如下：

> ```sql
> UPDATE t
>    SET column1 = expr1,
>        column2 = expr2,
>        ...
> [WHERE condition];
> 
> ```

其中，t 是要更新数据的表名；`SET` 子句指定了要更新的列和更新后的值，多个字段使用逗号进行分隔；满足 `WHERE` 条件的数据行才会被更新，如果没有指定条件，将会更新表中所有的行。





#### 删除记录

要删除表中的数据，使用 `DELETE` 语句。

> DELETE FROM tbl_name [WHERE where_condition]
> 
> 只有满足 `WHERE` 条件的数据才会被删除；如果省略 `WHERE` 条件，将会删除表中所有的数据。

```python
delete from users where id=6;
```

[注意] 删除某条记录后，再插入一条新的记录，自动编号不会补到删除记录的编号上，而是基于原有记录最大编号继续增加 。

在删除数据之前，可以使用相应的 `SELECT` 语句查看将要删除的数据。



#### 合并数据

在 SQL:2003 标准中，引入了一个新的数据操作命令：`MERGE` 。它可以同时完成 `INSERT` 和 `UPDATE` 的操作，甚至 `DELETE` 的功能。





#### **查找记录**

> SELECT EXPR,...FROM tbl_name
>
> SELECT select_expr [,select_expr...]
> [
> FROM tbl_references
> [WHERE where_condition]
> [GROUP BY {col_name | position} [ASC | DESC],...]
> [HAVING where_condition]
> [ORDER BY {col_name | expo | position}  [ASC | DESC],...]
> [LIMIT {[offset,] row_count | row_count OFFSET offset}]
> ]

查询表达式的每个表达式表示想要查找的一列，必须有至少一个。多个列之间以英文逗号分开， 查询 id, username 两列。

```sql
select id, username from users;
```

在使用多表连接时，可能会出现不同的表中存在名称相同的字段，如果直接写字段，分不清到底是哪张数据表的字段。在字段名前加上数据表可以分辨出隶属于哪张数据表。

```sql
select users,id, users, username from users;
```

星号`*`号表示所有的列。`tbl_name.*` 可以表示命名表的所有列 .

```sql
select * from users;
```

查询表达式可以使用 [AS] alias_name 为其赋予别名，别名可用于 `GROUP BY`, `ORDER BY`, `HAVING` 字句 .

```sql
select id AS userId, username AS uname from users;
```



##### 消除重复值

在 SQL 中，提供了`DISTINCT`关键字，用于删除查询结果中的重复值。例如：

```sql
SELECT DISTINCT
		first_name
	FROM employees;
```

`DISTINCT`位于`SELECT`之后，可以基于多个列值进行查重操作，通用语法如下：

```sql
SELECT DISTINCT
		column1,
		column2,
		...
	FROM table;
```

为了消除重复值，数据库系统需要对结果进行排序，然后扫描重复值；因此，大量数据的重复值处理会降低查询的速度。

除了`DISTINCT`之外，另一个关键字是`ALL`，它不会排除重复的结果，而是显示所有数据：

```sql
SELECT [ALL | DISTINCT]
		column1,
		column2,
		...
	FROM table;
```

如果不指定，默认值为`ALL`。

#### SQL中的注释

在 SQL 中，可以像其他编程语言一样使用注释，注释不会被执行。

SQL 中的注释分为单行注释和多行注释。

单行注释以两个连字符（–）开始，直到这一行结束。例如：

```sql
SELECT DISTINCT
		first_name --distinct will remove duplicate records
	FROM employees
```

多行注释使用C语言风格的注释方法（/* … */）。例如：

```sql
SELECT DISTINCT
		first_name
		/* distinct will remove
		   duplicate records from results
		*/
	FROM employees;
```

上面的查询中，总是返回表中的全部数据。但是更多情况下，我们只需要查看满足一定条件的结果。SQL中的`WHERE`关键字用于指定查询的条件。

#### 结果处理

##### 数据分组

`GROUP BY`子句，将数据分成不同的组，然后分别计算各个组内的聚合函数。

> [GROUP BY {col_name | position} [ASC | DESC],...]

　查询结果分组 (GROUP BY) 的参数中，ASC 是升序，是默认的；DESC 是降序

```sql
select * from users GROUP BY ager;

select * from users GROUP BY age DESC;
```

col_name 代表字段名，position 以数字代表位置，如 1 代表 SELECT 语句中第一次出现的字段。

```sql
select password, id, username, from users GROUP BY 1;
```

假如我们想要知道不同部分的平均薪水，而不是所有员工的平均值，可以使用以下语句：

```sql
SELECT department_id,
		AVG(salary)
	FROM employees
	GROUP BY department_id;
```

> 如果`GROUP BY`后的分组字段存在 NULL 值，多个 NULL 值将被看作一个分组。

在SQL查询中，如果同时存在`WHERE`子句和`GROUP BY`子句，要求`WHERE`子句在`GROUP BY`子句之前。因此，`WHERE`子句无法对分组后的结果进行过滤，例如：

##### 分组过滤

假设要查看员工数量大于 10 的部门编号，可以使用以下查询：

```sql
SELECT department_id,
		COUNT(*) AS headcount
	FROM employees
	GROUP BY department_id
	HAVING COUNT(*) > 10;
```

首先，按照部门编号进行分组，计算每个组内的员工数量；然后使用`HAVING`子句过滤员工数量大于 10 人的部门

假如要查看薪水大于 8000 的员工，数量大于 10 的部门编号，可以使用以下查询：

```sql
SELECT department_id,
		COUNT(*) AS headcount
	FROM employee
   WHERE salary > 8000
   GROUP BY department_id
 HAVING COUNT(*) > 10;
```

首先，`WHERE`子句过滤薪水大于 8000 的所有员工；然后，按照部门编号进行分组，计算每个组内的员工数量；最后，使用`HAVING`子句过滤员工数量大于 10 人的部门。



##### 分组条件

> [HAVING where_condition]

在设置分组 (HAVING) 时，一定要保证分组条件 (where_condition) 要么是聚合函数(max, min, avg, count, sum)，要么其中的字段必须是 SELECT 中的一个查询字段，否则会报错

![](https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426083828.png)

```sql
SELECT column1, column2,...
	FROM table
	WHERE conditions;
```

简单的示例：

```sql
SELECT first_name,
		last_name,
	FROM employees
   WHERE last_name = 'King';

```

在`WHERE`子句的条件中，允许使用各种比较运算符。



SQL 标准的语法：

```sql
SELECT column1,
       column2,
       aggregate_function(column3)
  FROM table1
[WHERE conditions]
[GROUP BY column1, column2]
[HAVING group_condition];

```



##### 单列排序

通过`SELECT`语句返回的查询结果，不保证结果的顺序。如果想要对查询结果进行排序显示，需要使用`ORDER BY`子句。

```sql
SELECT column1, column2, ...
	FROM table
  [WHERE condition]
  ORDER BY column1 ASC;
```

`ORDER BY`子句唯一`FROM`之后；如果查询包含`WHERE`条件，`ORDER BY`子句位于`WHERE`之后。`ASC`表示按照升序排序，`DESC`表示安装降序排序。默认为升序排序。

可以使用分组排序(order by)对查询结果进行排序

```sql
select * from users order by age;
```

除了按照列进行排序之外，也可以使用表达式的值进行排序。

##### 多列排序

ORDER BY 也可以指定多个排序的字段。

```sql
SELECT column1, column2, ...
	FROM table
   [WHERE condition]
   ORDER BY column1 ASC, column2 DESC;
```

如果指定多列排序，首先按照第 1 个指定的列进行排序，顺序相同的数据再按照第 2 个指定的列进行排序，以此类推。

除了使用列名指定排序顺序之外，SQL 还支持使用列在`SELECT`后出现的次序进行排序。例如

```sql
SELECT first_name,
		last_name,
		hire_date
	FROM employees
	ORDER BY 1 DESC, 2;
```

因为 first_name 在`SELECT`列表中第 1 个出现，last_name 第 2 个出现。

对于排序，需要注意的是字符串的大小写；有些数据库区分大小写，有些不区分。许多数据库还支持指定排序规则（COLLATE）。

> MySQL不区分大小写，“CAT”和“cat”相同
> MySQL升序排序时空值排在最前，降序排序时空值排在最后

 



##### 限制结果

SQL 标准中对查询结果进行限制的`OFFSET`子句和`FETCH`子句

> [LIMIT {[offset,] row_count | row_count OFFSET offset}]

限制查询结果(LIMIT)默认情况下，返回所有查找到的结果

如果 LIMIT 后面只有一个数字，表示从第一条开始返回，并返回相应数字个数的记录

```sql
select * from usres limit 2;
```

从第一条开始，返回两条记录。

SELECT 语句默认从0开始编号，如果想从第三条开始返回，则需要 offset 参数和 row_count 参数一起使用

```sql
select * from usres limit 2,2;

SELECT first_name, last_name, salary
  FROM employees
 ORDER BY salary DESC
 LIMIT 5, 10; -- return from 5th to 14th
 -- LIMIT 10 OFFSET 5;
```



###### Top-N 查询

由于不同数据库的实现存在较大差异，本篇先以 Oracle 12c 语法为例

```sql
SELECT first_name, last_name, salary
	FROM employees
	ORDER BY salary DESC
	FETCH FIRST 10 ROWS ONLY;
```

以上查询返回薪水最高的前 10 位员工。首先，`ORDER BY`子句定义了按照薪水从高到低排序；然后`FETCH`子句指定了只返回前 10 条记录。

###### 分页查询

考虑另一个场景，假如应用提供了分页显示的功能，每页显示 10 条记录，点击下一页时，需要显示第 11 到第 20 条记录。

```sql
SELECT first_name, last_name, salary
  FROM employees
 ORDER BY salary DESC
OFFSET 10 ROWS
 FETCH FIRST 10 ROWS ONLY;
```



SQL 标准中的完整定义：

```sql
SELECT column1, column2, ...
  FROM table
[WHERE conditions]
[ORDER BY column1 ASC, column2 DESC, ...]
[OFFSET m {ROW | ROWS}]
[FETCH { FIRST | NEXT } [ num_rows | n PERCENT ] { ROW | ROWS } { ONLY | WITH TIES }];

```

其中，`OFFSET` 表示偏移量，即从第 m+1 行开始返回；如果不指定，从第 1 行开始返回。

`FETCH` 用于指定返回多少行，`FIRST` 和`NEXT` 等价；num_rows 表示行数，n PERCENT 表示即按照百分比指定行数，`ROW` 和`ROWS` 等价；`ONLY` 和`WITH TIES` 的差别在于，如果最后存在更多排名相同的数据行，`WITH TIES`会返回更多的数据。

以下查询按照百分比返回前10%的数据：

```sql
SELECT first_name, last_name, salary
	FROM employees
	ORDER BY salary DESC
	FETCH FIRST 10 PERCENT ROWS ONLY;
```



##### 补充

> 
> INSERT [INTO] tbl_name [(col_name,...] SELECT ...
> 

这种方法可以将查找的结果存储到指定的数据表

```sql
create table t(
    id tinyint primary key ayto_increment,
    username varchar(20)
);

insert t(username) select username from users where age > 30;
```

将表 users 中符合条件的用户名插入到表 t 中。



### 记录约束

**空值**

> NULL         字段值可以为空
> NOT NULL     字段值禁止为空

**主键**

每张数据表只能存在一个主键 (PRIMARY KEY)，主键保证记录的唯一性，且自动为NOT NULL

主键可以写为 KEY 或 PRIMARY KEY

```python
create table tb(
	id smallint primary key,
    uername vahcar(20) not null
);
```

**自动编号**

自动编号(AUTO_INCREMENT)必须与主键组合使用，默认情况下，起始值为1，每次增量为1

```python
create table tb(
	id smallint auto_increment  primary key,
    uername vahcar(20) not null
);
```



**唯一**

唯一约束(UNIQUE KEY)是指选定的记录中不可以存在相同值的情况，这样可以保证记录的唯一性，唯一约束的字段可以为空值 NULL，每张数据表可以存在多个唯一约束

**默认值**

当插入记录时，如果没有明确为字段赋值，则自动赋予默认值 (DEFAULT)

```python
create table tb6(
	id int unsigend auto_increment key,
    username vachar(20) not null unique key,
    sex enum('1','2','3') default '3'
);
```



**外键**

外键约束(FOREIGN KEY)用来保持数据一致性和完整性，实现一对一或一对多的关系

外键列是指加入(FOREIGN KEY)的列，外键列参照的那一列叫做参照列，外键列和参数列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同



外键列和参照列必须创建索引，如果参照列不存在索引的话，MySQL将自动创建索引 。

子表指有外键列的表，子表所参照的表叫做父表。父表和子表必须使用相同的存储引擎，而且禁止使用临时表。数据表的存储引擎只能是 InnoDB 

主表

```python
CREATE TABLE ClassCharger(

       id TINYINT PRIMARY KEY auto_increment,
       name VARCHAR (20),
       age INT ,
       is_marriged boolean  -- show create table ClassCharger: tinyint(1)

);

INSERT INTO ClassCharger (name,age,is_marriged) VALUES ("冰冰",12,0),
                                                       ("丹丹",14,0),
                                                       ("歪歪",22,0),
                                                       ("姗姗",20,0),
                                                       ("小雨",21,0);
```

子表

```python
CREATE TABLE Student(

       id INT PRIMARY KEY auto_increment,
       name VARCHAR (20),
       charger_id TINYINT,     --切记:作为外键一定要和关联主键的数据类型保持一致
       -- FOREIGN KEY (charger_id)  REFERENCES ClassCharger(id)

) ENGINE=INNODB;

INSERT INTO Student(name,charger_id) VALUES ("alvin1",2),
                                            ("alvin2",4),
                                            ("alvin3",1),
                                            ("alvin4",3),
                                            ("alvin5",1),
                                            ("alvin6",3),
                                            ("alvin7",2);
```

增加外键和删除外键

```python
ALTER TABLE student  ADD CONSTRAINT abc
                     FOREIGN KEY(charger_id)
                     REFERENCES  classcharger(id);


ALTER TABLE student DROP FOREIGN KEY abc;
```

## **列操作**

### 添加单列

> 
> ALTER TABLE tb!_name ADD[COLUMN] col_name column_definition [FIRST|AFTER col_name];
> 

添加单列有三个位置选择，位于起始处，位于指定列的后面和位于最后

first 加入的放在整张表最前面，after 放在指定列后面，不填则放在整张表最后

### 添加多列

> 
> ALTER TABLE tb1_name ADD[COLUMN] (col_name column_definition,...);
> 

添加多列只能位于最后 。

### **删除单列**

> 
> ALTER TABLE tb1_name DROP [COLUMN] col_name
> 

### 删除多列

> 
> ALTER TABLE tb1_name DROP col1_name, DROP col2_name, ...
> 



### 修改列

#### 修改列定义

对于一个已有的表，可能会由于业务变更或者代码重构需要修改它的结构。

修改列定义指修改列的类型或位置

> 
> ALTER TABLE table_name action;
> 

其中的 action 表示要对表执行的操作，常见的操作包括增加列，修改列，删除列；增加约束，修改约束，删除约束等等。



将字段'id'的类型由smallint转换为tinyint

[注意]在由大范围的类型转换为小范围类型时，可能会造成数据丢失

```sql
alter table1 user2 modify id tinyint unsigend not null
```

首先是为表增加一个新的字段：

```sql
ALTER TABLE table_name
	ADD [COLUMN] column_name date_type column_constraint;
```

添加字段的内容和创建表时类似，包括字段名、数据类型以及可选的列约束。

> MySQL 支持为新增的列指定位置：
> `ALTER TABLE table_name`
> `ADD [COLUMN] column_name data_type column_constraint FIRST | AFTER some_column;`

有时候我们需要修改表中字段的某些属性，比如数据类型，约束等。SQL 使用 `ALETR TABLE ... ALTER COLUMN` 语句修改字段的属性：



#### 修改列名称

使用下面的 CHANGE 语法，比 MODIFY 语法更加强大，可以在修改列名称的同时，修改列类型 。

> 
> ALTER TABLE tb1_name CHANGE  old_col_name new_col_name column_definition [FIRST|AFTER col_name]
> 

```sql
ALTER TABLE emp_identity RENAME COLUMN last_name TO family_name;

```



##  约束操作

### 添加主键约束

> 
> ALTER TABLE tb1_name ADD  PRIMARY KEY (index_col_name,...)
> 

### 添加唯一约束

唯一约束与主键约束的不同之处在于，唯一约束可以存在多个字段，而主键约束只能有一个

> 
> ALTER TABLE tb1_name ADD  UNIQUE [INDEX|KEY] [index_name] [index_type]
> 



### **添加外键约束**

>
> ALTER TABLE tb1_name ADD [CONSTRAINT[symbol]] FOREIGN KEY [index_name] (index_col_name,...) reference_definition
> 

```
alter table user2 add foreign key (pid) references provinces(id);
```

*provinces 为另一个表名



### 删除主键约束

> 
> ALTER TABLE tbl_name DROP PRIMARY KEY
> 

### 删除唯一约束

> 
> ALTER TABLE tbl_name DROP {INDEX|KEY} index_name
> 

### **删除外键约束**

> 
> ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol
> 



## 数据表更名

> 
> ALTER TABLE tb1_name RENAME [TO|AS] new_tb1_name
> 



使用 RENAME 方法可以为多张数据表更名

> 
> RENAME TABLE tb1_name TO new_tbl_name [,tbl_name2 TO new_tbl_name2] ...
> 



## 中文乱码问题

### 配置文件

解决中文识别问题的第一步是修改 mysql 的配置文件 my.ini

在 [client] 下添加

```sql
default-character-set = utf8
```

在 [mysqld] 下添加

```sql
character-set-server = utf8
```

然后重新启动服务

### 数据库编码

新建一个数据库

```sql
create database db4
```

通过下列代码查看数据库的编码类型

```sql
show create database db4
```

查看编码类型是否是 utf8，如果不是，则使用下列代码修改为 utf8

```sql
set names utf8
```

### 数据表编码

新建数据表

```sql
create table if not exists tdb
```

查看数据表的编码类型

```sql
show cearte tabel tdb
```

查看编码类型是否是 utf8，如果不是，则使用下列代码修改为 utf8

```sql
SET NAMES utf8
```

## 子查询

查询数据库，当查询条件比较复杂时，常常需要用到子查询。子查询(Subquery)是指出现在其他SQL语句内的 `SELECT` 子句。

### 定义

子查询 (Subquery) 是指出现在其他 SQL 语句内的 SELECT 子句

```sql
SELECT * FROM t1 WHERE col1 = (SELECT col2 FROM t2);
```

其中，SELECT * FROM t1，称为外层查询(Outer Query/Outer Statement)，SELECT col2 FROM t2，称为子查询 (SubQuery)



在使用子查询时，需要注意的是

1. 子查询指嵌套在查询内部，且必须始终出现在圆括号内

2. 子查询语句中可以包含多个关键字或条件，如 DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等

3. 子查询的外层查询可以是：SELECT、INSERT、UPDATE、SET 或 DO

4. 子查询返回值可以是：标量、一行、一列或者子查询

假设我们想要知道哪些员工的薪水大于所有员工薪水的平均值。首先，我们可以查询出所有员工的平均薪水值：

```sql
SELECT AVG(salary)
 FROM employees;
```

结果约为 6462 。然后，我们查询那些薪水大于该值的员工信息：

```sql
SELECT first_name,
		last_name,
		salary
	FROM employees
  WHERE salary > 6462
  ORDER BY salary;
```

以上示例中我们使用了两个查询来解决问题，但是实际问题往往更加复杂；通过使用子查询，可以一次解决问题，同时还能实现更多功能：

```sql
SELECT first_name,
	   last_name,
	   salary
	FROM employees
  WHERE salary > (
      			SELECT AVG(salary)
        		FROM employees  
  	  		)
  ORDER BY salary;
```

以上查询包含两个`SELECT`语句，括号内部的查询称为子查询，子查询也称为内查询（inner query）或者嵌套查询（nested query），包含子查询的查询称为外查询（outer query）。

在 SQL 标准定义中，子查询分为以下类型：

- **标量子查询（scalar query）**：返回单个值（一行一列）的子查询。上面的示例就是一个标量子查询。
- **行子查询（row query）**：返回包含一个或者多个值的单行结果（一行多列），标量子查询是行子查询的特例。
- **表子查询（table query）**：返回一个虚拟的表（多行多列），行子查询是表子查询的特例。


#### 标量子查询

标量子查询可以当作一个标量值使用。

##### SELECT 子句中的标量子查询

```sql
SELECT first_name,
		last_name,
		salary,
		salary - (SELECT ROUND(AVG(salary),0)
					FROM employees) AS difference
	FROM employees
  ORDER BY first_name, last_name;
```

##### WHERE 子句中的标量子查询

在 SQL 语句的`WHERE`子句中，可以将列值与一个标量子查询的结果进行比较运算，返回满足条件的数据：

```sql
SELECT first_name,
		last_name,
		salary
	FROM employees
  WHERE salary = (SELECT MAX(salary)
                 	FROM employees)
  ORDER BY first_name, last_name;
```

标量子查询除了用于`SELECT`和`WHERE`子句之外，也可以出现在`GROUP BY`、`HAVING`以及`ORDER BY`子句中，使用方法类似。



#### 行子查询

行子查询可以当作一个一行多列的表使用。

```sql
SELECT first_name,
		last_name,
		salary
	FROM employees
  WHERE (first_name, last_name) = 
  				(SELECT MAX(first_name), MAX(last_name)
                	FROM employees
                )
 ORDER BY first_name, last_name;
```

以上查询中的子查询返回一个一行两列的值，然后在外查询的`WHERE`条件中查找姓和名都匹配该值的员工信息。

**对于使用行子查询或标量子查询的情况，需要注意子查询结果不能返回多行**。



#### 表子查询

表子查询可以当作一个表使用。

##### FROM 子句中的表子查询

在 FROM 子句中的子查询，相当于创建了一个临时表，可以作为查询的一个数据源使用：

```sql
SELECT column1, column2, ...
  FROM (subquery) [AS table_alias];

```

示例

```sql
SELECT d.department_name,
		ds.sum_salary
	FROM department d
	JION (SELECT department_id,
         		 SUM(salary) AS sum_salary
         	FROM employees
           GROUP BY department_id) ds
      ON (d.departmrnt_id = ds.department_id)
    ORDER BY d.derpartment_name;
        
```

> 不同数据库产品对于 FROM 子句中的子查询称呼不同。例如，MySQL 称为派生表（derived table）

##### WHERE 子句中的表子查询

如果子查询返回多行记录，不能使用普通的比较运算符（例如等于）进行判断；需要使用其他运算符。

首先，我们可以使用`[NOT] IN`检查某个值是否包含在列表中：

```sql
SELECT first_name,
       last_name,
       salary
  FROM employees
 WHERE job_id IN (SELECT job_id
                    FROM jobs
                   WHERE max_salary <= 10000)
ORDER BY first_name , last_name;

```

子查询获取了所有最高薪水小于等于 10000 的职位列表，然后外查询使用`IN`运算符返回属于这些职位的员工信息。如果使用`NOT IN`运算符，则返回不属于这些职位的员工信息。

#### 关联子查询

关联子查询会引用外部查询中的列，因而与外部查询产生关联。关联子查询对于外查询中的每一行都会运行一次（数据库可能会对此进行优化），而非关联子查询在整个查询运行时只会执行一次。

```sql
SELECT job_id,
       first_name,
       last_name,
       salary
  FROM employees o
 WHERE salary = (SELECT MAX(salary)
                   FROM employees i
                  WHERE i.job_id = o.job_id)
 ORDER BY job_id, first_name;

```

子查询的`WHERE`子句中使用了外查询的 job_id 字段作为判断条件，因此外查询先检索出所有的 employees 数据，针对每一行数据，将 job_id 传递给子查询；子查询获取每个职位的最高薪水，然后再根据薪水值对外部的数据行进行过滤；直到外查询中的所有行都被处理完成。

除了`WHERE`子句外，`SELECT`列表中也可以使用关联子查询：

```sql
SELECT d.department_name,
       (SELECT SUM(salary)
          FROM employees e
         WHERE e.department_id = d.department_id) AS sum_salary
  FROM departments d
  ORDER BY d.department_name;

```





### 比较运算符

使用比较符是其中一类子查询

比较运算符包括 =、!=、<>、<=> 、>、<、>=、<=

### 逻辑条件

**AND** 

```sql
SELECT first_name,
		last_name,
		salary
	FROM employees
   WHERE job_id = 'IT_PROG'
     AND salary > 5000;
		
```

`AND`运算符指定了两个条件，只有当它们都为真时，结果才为真；否则结果为假，不返回结果。





**OR**

与`AND`类似的还有`OR`运算符，它也可以组合多个查询条件；但是`OR`只要有一个条件为真，结果就为真。

```sql
SELECT first_name,
		last_name,
		job_id,
		salary
	FROM employees
   WHERE job_id = 'AD_PRES'
     OR job_id = 'AD_VP';
```

对于逻辑运算符`AND`和`OR`，SQL使用短路运算，也就是说，只要前面的表达式能够决定最终的结果，不进行后面的计算。这样能够提高运算效率。因此，以下条件不会产生除零错误：

```sql
1 = 0 AND 1/0 = 1;
1 = 1 OR 1/0 = 1;
```

通过结合运算符`AND`和`OR`，可以构造更加复杂的查询条件。假设我们想要查询 job_id 等于 “IT_PROG” 或者 “SA_REP”，并且薪水大于 10000 的员工信息：

```sql
SELECT first_name,
		last_name,
		job_id,
		salary
	FROM employees
	WHERE job_id = 'IT_PROG'
		OR job_id = 'SA_REP'
		AND salary > 10000;
```

**NOT**

除了`AND`和`OR`之外，`NOT`运算符用于取反操作，它的逻辑真值表如下：

|       |  NOT  |
| :---: | :---: |
| TRUE  | FALSE |
| FALSE | TRUE  |
| NULL  | NULL  |

除此之外，`NOT`还可以结合前面介绍的运算符一起使用：

- `NOT BETWEEN`，位于范围之外
- `NOT IN`，不在列表之中
- `NOT LIKE`，不匹配模式
- `NOT EXISTS`，子查询不存在结果
- `NOT IS NULL`，不为空，等价于`IS NOT NULL`



### 修饰关键字

修饰关键字包括 ANY、SOME、ALL 三个，如果子查询返回多个值时，可以使用它们

> operand comparison_operator  ANY（子查询）
> operand comparison_operator  SOME（子查询）
> operand comparison_operator  ALL（子查询

|        |  ANY   |  SOME  |  ALL   |
| :----: | :----: | :----: | :----: |
| > ,>=  | 最小值 | 最小值 | 最大值 |
| <, <=  | 最大值 | 最大值 | 最小值 |
|   =    | 任意值 | 任意值 |        |
| <>, != |        |        | 任意值 |

#### 处理情况

1. 运算符为 >或 >=，使用 ANY 关键字时，表示大于子查询结果中的最小值

2. 运算符为 > 或 >=，使用 ALL 关键字时，表示大于子查询结果中的最大值

3. 运算符为 < 或 <=，使用 ANY 或 SOME 关键字时，表示小于子查询结果中的最大值；使用ALL关键字时，表示小于子查询结果中的最小值

4. 运算符为=，使用ANY或SOME关键字时，表示等于子查询结果中的任意值；使用ALL关键字时，则返回空



### [NOT] IN

第二种子查询是由IN 或 NOT IN引发的子查询，与比较运算符使用的方法基本相同 

> 其中，= ANY 运算符与 IN 等效，!= ALL或 <> ALL运算符与 NOT IN 等效



### [NOT] EXISTS

第三种子查询是由 `EXISTS` 或  `NOT EXISTS` 引发的子查询。如果子查询返回任何行，`EXISTS` 将返回 TRUE；否则返回 FALSE





### 存储查询结果

可以把查询结果统一存储到一个新的数据表中，而不需要一条一条地录入

创建一个新的表

```sql
CREATE TABLE IF NOT EXISTS tdb(
    cate_id SMALLINT PRIMARY KEY AUTO_INCREMENT,
    cate_name VARCHAR(20) NOT NULL
);
```

查询表中的所有记录，并按 ’ 类别 ‘ 进行分组

```sql
SELECT good_cate FROM tdb GROUP BY good_cate;
```

将分组结果写入到 “商品分类” 数据表中。

> 
> INSERT [INTO] tbl_name [(col_name),...)] SELECT...;
> 



```sql
INSERT tdb(cate_name) SELECT good_cate FROM tdb_goods GROUP BY good_cate;
```



<https://www.cnblogs.com/xiaohuochai/p/6077677.html>





## 函数

mysql 数据库中的函数根据功能可以划分为字符函数、数值运算符与函数、比较运算符与函数、日期时间函数、信息函数、聚合函数、加密函数以及自定义函数等。

### 字符串函数

|  函数名称   |           描述           |
| :---------: | :----------------------: |
|  CONCAT()   |         字符链接         |
| CONCAT_WS() | 使用指定的分隔符链接字符 |
|  FORMAT()   |        数字格式化        |
|   LOWER()   |      转换成小写字母      |
|   UPPER()   |      转换成大写字母      |
|   LEFT()    |       获取左侧字符       |
|   RIGHT()   |       获取右侧字符       |



|     名称     |        描述        |
| :----------: | :----------------: |
|   LENGTH()   |   获取字符串长度   |
|   LTRIM()    |    删除前导空格    |
|   RTRIM()    |    删除后续空格    |
|    TRIM()    | 删除前导和后续空格 |
| SUBSTRING()  |     字符串截取     |
| [NOT] LIKE() |      模式匹配      |
|  REPLACE()   |     字符串替换     |

**CONCAT()** 用于字符连接

```sql
SELECT CONCAT('a', 'b');

SELECT CONCAT('a', '-', 'b');
```

CONCAT() 函数也可用于将一个数据表中的两个字段的所有记录进行字符连接

```sql
SELECT CONCAT(username, age) AS full FROM test;
```



**CONCAT_WS()**

使用指定的分隔符进行字符连接，该函数的第一个参数是指定分隔符

```sql
SELECT CONCAT_WS('|', '1', '2', '3');
```

结果：

1 | 2 |3

**FORMAT()**

主要用于数字格式化，最终返回一个字符型数字。第一个参数为待格式化的数字，第二个参数为要保留的小数位数　

```sql
SELECT FORMAT(12345.44677, 2);
```





**REPLACE()** 

用于字符串的替换

```sql
SELECT REPLACE ('MySQL', 'L', '-');
```

将字符 ‘L’ 替换为 ‘-’

**SUBSTRING()**

用于字符串截取，第一个参数是开始截取的起始位置，第二个参数是截取的字符数目, 如果省略第二个参数，则一直截取到字符串的结尾

> [注意]这里是从1开始计数的，而不是从0开始的

**[NOT] LIKE**

用于模式匹配，其中 

- % 代表 0 个或多个字符，
- `_` 代表任意 1 个字符。返回 1 表示匹配，0 表示不匹配

如果要匹配通配符（% 或 _ ）自身，可以在它们前面加上一个反斜杠（\）进行转义。

![](https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426104332.png)



### 数学运算符

|    名称    |   描述    |
| :--------: | :-------: |
|   CEIL()   | 进 1 取整 |
|   DIV()    | 整数除法  |
|  FLOOR()   | 舍 1 取整 |
|   MOD()    |  取余数   |
|  POWER()   |  幂运算   |
|  ROUND()   | 四舍五入  |
| TRUNCATE() | 数字截取  |

**CEIL()** 函数主要用于进一取整(向上取整)

```sql
SELECT CEIL(3.1);
```

结果为 4

**FLOOR()** 函数主要用于舍一取整(向下取整)

```sql
SELECT FLOOR(3.9);
```

结果为 3

**ROUND()** 函数主要用于四舍五入，两个参数分别为浮点数和保留的小数位数, 默认只保留整数部分

```sql
SELECT ROUND(3.36);

SELECT ROUND(3.36, 1);
```



**DIV()** 主要用于整数的除法

```sql
SELECT 7 DIV 2;
```

**MOD()** 主要用于取余数 等同于 % 可以是整数，也可以是小数。

```sql
SELECT 5 % 3;

SELECT 5 MOD 3;
```



**POWER()** 主要用于幂运算

```sql
SELECT POWER(3,2);
```

**TRUNCATE()** 主要用于数字截取，两个参数分别为数值和截断到小数点后 n 位 。

```sql
SELECT TRUNCATE(33.33, 1);

SELECT TRUNCATE(33.33, 0);
```



### 比较运算符

|           名称            |         描述          |
| :-----------------------: | :-------------------: |
| [NOT] BETWEEN ... AND ... |    [不] 在范围之内    |
|         [NO] IN()         | [不] 在列出值范围之内 |
|       IS [NOT] NULL       |       [不] 为空       |

**[NOT] BETWEEN ... AND ...**

```sql
SELECT 10 BETWEEN 5 AND 20;
```

**[NO] IN()**

```sql
SELECT 10 IN (5, 10, 15,20);
```

**IS [NOT] NULL**

```sql
SELECT 0 IS NULL;
```

### 时间日期

|     名称      |      描述      |
| :-----------: | :------------: |
|     NOW()     | 当前日期和时间 |
|   CURDATE()   |    当前日期    |
|   CURTIME()   |    当前时间    |
|  DATE_ADD()   |    日期变换    |
|  DATEDIFF()   |    日期差值    |
| DATE_FORMAT() |   日期格式化   |

**NOW()** 返回当前日期和时间

```sql
SELECT NOW();
```

**CURDATE()** 返回当前日期

```sql
SELECT CURDATE();
```

**CURTIME()** 返回当前时间

```sql
SELECT CURTIME();
```

**DATE_ADD()** 函数日期变化，可以增加，也可以减少

```sql
SELECT DATE_ADD('2016-11-19',INTERVAL 365 DAY);

SELECT DATE_ADD('2016-11-19',INTERVAL -365 DAY);

SELECT DATE_ADD('2016-11-19',INTERVAL 1 YEAR);
```

**DATEDIFF()** 函数日期差值，两个日期的差值

```sql
SELECT DATEDIFF('2016-11-19', '2015-11-19');
```

返回值为 DAY

**DATE_FORMAT()** 函数进行日期格式化

```sql
SELECT DATE_FORMAT('2016-11-19', '%m/%d/%Y');
```

### 信息函数

|       名称        |         描述         |
| :---------------: | :------------------: |
| CONNECTION_ID（） |       连接 ID        |
|    DATABASE()     |      当前数据库      |
| LAST_INSERT_ID()  | 最后插入记录的 ID 号 |
|      USER()       |       当前用户       |
|     VERSION()     |       版本信息       |

**CONNECTION_ID()**  返回连接 ID (线程 ID)

```sql
SELECT CONNECTION_ID();
```

**DATABASE()** 返回当前数据库名称

```sql
SELECT DATABASE();
```

**LAST_INSERT_ID()** 返回最后插入记录的ID，当一次性写入多条记录时，函数返回的ID为第一条记录的ID

```sql
SELECT LASR_INSERT_ID();
```

**USER()** 返回当前用户

**VERSION()** 返回版本信息

```sql
SELECT USER();

SELECT VERSION();
```



### 聚合函数

| 名称    | 描述   |
| ------- | ------ |
| AVG()   | 平均值 |
| COUNT() | 计数   |
| MAX()   | 最大值 |
| MIN()   | 最小值 |
| SUM()   | 求和   |

聚合函数只能用于数据表，不能用于单个数值的计算

```sql
SELECT AVG(1, 2, 3)
```

关于聚合函数，需要注意两点：

- 在参数中使用`DISTINCT`，可以在计算之前排除组内的重复值；
- 聚合函数在计算时，忽略输入为 NULL 值的行。

### 加密函数

|    名称    |     描述     |
| :--------: | :----------: |
|   MD5()    | 信息摘要算法 |
| PASSWORD() |   密码算法   |

**MD5()** 

**PASSWORD()**   密码算法，通过PASSWORD()修改当前用户和其他用户的密码，修改客户端自己的密码

```sql
SELECT PASSWORD('MySQL');
```



### 自定义函数

函数可以返回任意类型的值，同样可以接收这些类型的参数。函数参数和返回值之前没有必然的联系

[注意]一个函数最多可以有1024个参数

用户自定义函数 (user-defined function, UDF) 是一种对 MySQL 扩展的途径，其用法与内置函数相同

自定义函数的两个必要条件：**1、参数；2、返回值**

#### 创建自定义函数

```sql
CREATE FUNCTION function_name
RETURNS
{STRING|INTEGER|REAL|DECIMAL}
routine_body
```

关于自定义函数的函数体

1. 函数体可以由合法的 SQL 语句构成；

2. 函数体可以是简单的 SELECT 或 INSERT 语句；

3. 函数体如果为复合结构则使用 BEGIN...END 语句；

4. 复合结构可以包含声明、循环、控制结构。



#### 创建不带参数的自定义函数

```sql
CREATE FUNCTION f1() RETURNS VARCHAR(30)
RETURN DATE_FORMAT(NOW(), '%Y年%m月%d日 %H点:%i分:%s秒');


SELECT f1();
```

#### **创建带参数的自定义函数**

```sql
CREATE FUNCTION f2(num1 SMALLINT UNSIGNED,num2 SMALLINT UNSIGNED) 
RETURNS FLOAT(10,2) UNSIGNED 
RETURN  (num1+num2)/2;


SELECT f2(2,6)
```

[注意]如果自定义函数存在符合结构的多个语句，函数体要包含在BEGIN...END内，同时，需要通过DELIMITER将默认的结束符 ; 修改成其他符号，如：//  $$  ，以免函数由于语句结尾的 ; 号导致中断

### 删除函数

```
DROP FUNCTION [IF EXISTS] function_name
```



## **多表连接查询**

在实际应用中，常常需要从两个或更多的表中同时返回相关联的信息。

例如，我们在查询员工信息时，只能看到他/她所在的部门编号，如果想要同时显示部门的名称，就需要连接 employees 表和 departments 表中的信息。

```sql
SELECT departments.department_id, 
       employees.department_id,
       department_name,
       employees.first_name,
       employees.last_name
  FROM employees
 INNER JOIN departments
    ON employees.department_id = departments.department_id;
```

首先，引入了新的关键字：`INNER JOIN`和`ON`。`INNER JOIN`表示内连接，这里表示要连接 employees 表和 departments 表；`ON`用于指定连接条件，这里表示 employees 中的部门编号等于 departments 的部门编号。


对于内连接，只有满足连接条件的行才会被返回。

另外，我们在`SELECT`列表中的某些字段名之前加上了表名限定，例如 departments.department_id，这是因为两个表中都存在部门编号，必须明确指定需要显示哪个表中的信息。但是，如果某个字段只存在一个表中，可以省略表名，例如 department_name。

为了便于了解字段的来源，建议总是加上表名限定。但是如果总是写上表的全名，输入时非常麻烦，也不便于阅读，因此我们引入了表的别名。

### 使用表别名

修改一下上面的示例，加上表别名：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
  FROM employees AS e
 INNER JOIN departments AS d
    ON e.department_id = d.department_id;

```

通过在表名后面加上关键字`AS`，我们为 employees 表指定了别名 e，为 departments 表指定了别名 d。然后在查询的其他地方使用了表别名。

### 连接类型

SQL 中的连接主要包括以下类型：

- INNER JOIN，内连接
- LEFT OUTER JOIN，左外连接
- RIGHT OUTER JOIN，右外连接
- FULL OUTER JOIN，全外连接
- CROSS JOIN，交叉连接
- NATURAL JOIN，自然连接
- Self Join，自连接

其中，左外连接、右外连接以及全外连接统称为外连接（OUTER JOIN）。

### 内连接

内连接使用关键字`INNER JOIN`表示，也可以简写成`JOIN`； 内连接只返回两个表中匹配的数据行。参考以下示意图（基于两个表的 id 进行连接）：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426213910.png"/>

其中，id = 1 和 id = 3 是两个表中匹配的数据，因此内连接返回了 2 行记录。



### 左外连接

左外连接使用关键字`LEFT OUTER JOIN`表示，也可以简写成`LEFT JOIN`； 左外连接返回左表中所有的数据行；对于右表中的数据，如果没有匹配的值，返回空值。参考以下示意图（基于两个表的 id 进行连接）：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426215634.png"/>

其中，id = 2 在 table1 中存在，在 table2 中不存在；左外连接仍然会返回该记录，只是对于 table2 中的列，返回的是空值。

假如我们想要查看部门和其员工信息，考虑到某些部门可能还没有员工，如果使用内连接，无法显示这些部门，因此使用左外连接：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
  FROM departments d
  LEFT JOIN employees e
    ON e.department_id = d.department_id
 WHERE d.department_id IN (110, 120, 130);
```

### 右外连接

右外连接使用关键字`RIGHT OUTER JOIN`表示，也可以简写成`RIGHT JOIN`； 右外连接返回右表中所有的数据行；对于左表中的数据，如果没有匹配的值，返回空值。参考以下示意图（基于两个表的 id 进行连接）：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200426215910.png"/>

也就是说：

```sql
table1 RIGHT JOIN table2
```

等价于

```sql
table2 LEFT JOIN table1
```

假如我们想要查看部门和其员工信息。考虑到某些员工可能还没有分配部门，如果使用内连接，无法显示这些员工；因此使用右外连接：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
  FROM departments d
 RIGHT JOIN employees e
    ON d.department_id = e.department_id
 WHERE e.employee_id IN (176, 177, 178);

```



### 全外连接

全外连接使用关键字`FULL OUTER JOIN`表示，也可以简写成`FULL JOIN`。

全外连接等效于左外连接加上右外连接，返回左表和右表中所有的数据行。参考以下示意图（基于两个表的 id 进行连接）：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427073319.png"/>

需要注意的是，对于重复的行（id = 1 和 id = 3），只返回一次记录。

假如我们想要查看部门和其员工信息，需要同时考虑到某些部门可能还没有员工，而且某些员工可能还没有分配部门，使用全外连接：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
     FROM departmrnt d
     FULL JION employees e
       ON d.department_id = e.department_id
     WHERE e.employee_id IN (176, 177, 178)
     	OR d.department_id IN (110, 120, 130);
```

对于内连接和外连接，如果满足以下条件，可以使用`USING`替代`ON`，简化连接条件的输入：

- 连接条件是等值连接，即 t1.col1 = t2.col1
- 两个表中的列必须同名同类型，即 t1.col1 = t2.col1

内连接查询示例，由于 employees 表和 departments 表中的 department_id 字段名称和类型都相同，可以使用`USING`简写成以下语句：

```sql
SELECT d.department_id, 
       e.department_id,
       d.department_name,
       e.first_name,
       e.last_name
  FROM employees e
 INNER JOIN departments d
 USING (department_id);

```

多表连接的示例。

```sql
SELECT d.ddepartment_name,
	   e.first_name,
	   e.last_name,
	   j.job_title
	FROM department d
  INNER JOIN employee e ON d.department_id = e.department_id
  INNER JION jobs j    ON j.job_id = e.job_id
```

对于多个表的连接，按照出现的顺序进行连接；如有必要，可以使用括号 () 修改连接的顺序：

```sql
SELECT d.department_name,
       e.first_name,
       e.last_name,
       j.job_title
  FROM departments d
 INNER JOIN (employees e
       INNER JOIN jobs j
          ON j.job_id = e.job_id)
    ON d.department_id = e.department_id;

```



## SQL 查询执行顺序

示例

```sql
SELECT DISTINCT t1.column1 AS alias1, t2.col2, aggregate_function(column3)
  FROM table1 t1
  JOIN table2 t1 ON t1.column1 = t2.column1
 WHERE conditions
 GROUP BY t1.column1, t2.col2
HAVING group_condition
 ORDER BY t1.column1 ASC, t2.col2 DESC
OFFSET m ROWS
 FETCH NEXT num_rows ROWS ONLY;

```

以上就是 SQL 语法中常见的各个子句（当然不是全部子句）的书写顺序，但是它们的逻辑执行顺序却与此不同：

1. 首先，`FROM`和`JOIN`是SQL执行的第一步，它们从逻辑上决定了接下来要操作的数据集；

2. 其次，执行`WHERE`子句，对上一步的数据集进行过滤，保留满足条件的行；需要注意的是，此时还没有执行`SELECT`子句，`WHERE`条件中不能引用`SELECT`列表中的列别名（alias1）或者聚合函数
3. 接下来，基于`GROUP BY`子句指定的表达式进行分组，分组条件有多少不同的取值，操作后的结果就有多少行；
4. 然后，基于分组结果执行聚合函数 aggregate_function，对于每个分组取值，生成一个函数结果；如果没有分组子句，基于所有结果执行一次聚合操作；
5. 如果查询中使用了`GROUP BY`，可以使用`HAVING`针对分组后的结果进一步进行过滤，通常是利用聚合函数的值进行过滤，如果是其他过滤条件，可以在`WHERE`子句中提前指定，避免无谓的操作；
6. 接下来，`SELECT`子句可以选择要显示的列。如果存在`GROUP BY`子句，`SELECT`列表只能引用分组所使用的列，或者聚合函数；如果不存在`GROUP BY`子句，可以引用`FROM`和`JOIN`指定的表中的任何列；
7. 如果在`SELECT`之后指定了`DISTINCT`关键字，需要针对上一步的结果集进行去重操作，过滤掉所有重复的值；
8. 应用`ORDER BY`子句对上一步的结果进行最终的排序操作。如果存在`GROUP BY`子句或者`DISTINCT`关键字，只能使用`SELECT`列表中出现的字段进行排序；如果不存在`GROUP BY`子句和`DISTINCT`，可以使用`FROM`和`JOIN`指定的表中的任何列；
9. 最后，`OFFSET`和`FETCH`（或者`LIMIT`、`TOP`）限定了返回的行。



## SQL 中的条件表达式

SQL 是一种声明性的语言，它没有提供其他编程语言中的条件语句（if-then-else 或者 switch）。但是，SQL 支持 CASE 表达式，可以基于一个条件列表返回不同的结果值，它更像是一种支持嵌套的三元表达式（? :）。

CASE 表达式支持两种形式：简单 CASE 表达式和搜索 CASE 表达式。另外，还存在一些简写形式的 CASE 函数，以及不同数据库产品特有的扩展。


### 简单 CASE 表达式

简单 CASE 表达式的语法如下：

```sql
CASE expression
  WHEN expression_1 THEN result_1
  WHEN expression_2 THEN result_2
  ...
  [ELSE default_result]
END

```

简单 CASE 表达式比较`CASE`后的表达式与`WHEN`列表中的表达式的值，找到第一个匹配的值（=），返回后面相应的结果；如果没有匹配值，返回`ELSE`子句的值；如果此时没有指定`ELSE`子句，返回空值。

示例

```sql
SELECT e.first_name,
       e.last_name,
       e.job_id,
       CASE e.job_id
         WHEN 'AD_PRES' THEN 'President'
         WHEN 'AD_VP'   THEN 'Administration Vice President'
         WHEN 'IT_PROG' THEN 'Programmer'
         ELSE 'Other job'
       END
  FROM employees e;

```

简单 CASE 表达式仅仅比较两个值是否相等，然后返回相应的值。如果我们想要基于更加复杂的条件进行判断，例如某个值是否为空，某个值是否大于指定的数值，甚至使用子查询的结果进行判断，都需要使用更加强大的搜索 CASE 表达式。

### 搜索 CASE 表达式

搜索 CASE 表达式的语法如下：

```sql
CASE
  WHEN condition_1 THEN result_1
  WHEN condition_2 THEN result_1
  ...
  [ELSE default_result]
END

```

表达式按照顺序计算`WHEN`子句中的条件，找到第一个结果为 True 的分支，返回相应的结果；如果没有任何条件为真，返回`ELSE`中的默认值；如果此时没有指定`ELSE`子句，返回空值。

```sql
SELECT e.first_name,
       e.last_name,
       e.salary,
       CASE
         WHEN e.salary < 5000  THEN 'Low'
         WHEN e.salary < 10000 THEN 'Middle'
         WHEN e.salary < 15000 THEN 'High'
         ELSE 'Top'
       END AS salary_level
  FROM employees e;

```

CASE 表达式除了可以用于`SELECT`列表，也可以出现在其他 SQL 子句中，例如`WHERE`条件、`GROUP BY`分组、`ORDER BY`排序等。

```sql
SELECT CASE
         WHEN e.salary < 5000  THEN 'Low'
         WHEN e.salary < 10000 THEN 'Middle'
         WHEN e.salary < 15000 THEN 'High'
         ELSE 'Top'
       END AS salary_level,
       MIN(e.salary) min_salary,
       MAX(e.salary) max_salary
  FROM employees e
 GROUP BY CASE
            WHEN e.salary < 5000  THEN 'Low'
            WHEN e.salary < 10000 THEN 'Middle'
            WHEN e.salary < 15000 THEN 'High'
            ELSE 'Top'
          END;

```

### 缩写 CASE 表达式

除了以上两种形式的 CASE 表达式之外，SQL 还定义了两个与 NULL 值相关的缩写 CASE 表达式（函数）：nullif 和 coalesce。

NULLIF 函数需要2个参数，如果第一个参数等于第二个参数，返回 NULL 值；否则，返回第一个参数的值：

```sql
NULLIF(expression_1, expression_2)
```

它的等价 CASE 表达式如下：

```sql
CASE
  WHEN expression_1 = expression_2 THEN NULL
  ELSE expression_1
END

```

NULLIF 函数的一个常见用途是防止除零错误：

```sql
value1 / NULLIF(value2 , 0)

```

COALESCE 函数接受一个参数列表，并且返回第一个非空的参数值；如果所有参数都为空，返回空值：

```sql
COALESCE(expression_1, expression_2, expression_3, ...)

```

它的等价 CASE 表达式如下：

```sql
CASE
WHEN expression_1 IS NOT NULL THEN expression_1
WHEN expression_2 IS NOT NULL THEN expression_2
WHEN expression_3 IS NOT NULL THEN expression_3
...
END

```

示例：

```sql
SELECT e.first_name,
       e.last_name,
       COALESCE(e.commission_pct, 0)
  FROM employees e;

```

如果员工存在佣金百分比，返回该值；否则，显示为 0。

### 扩展函数

MySQL 提供了 IF 函数：

```sql
IF(expr1, expr2, expr3)

```

它接受三个参数。如果第一个参数为真（expr1 <> 0 并且 expr1 不为空），返回第二个参数的值；否则，返回第三个参数的值。

```sql
-- For MySQL only
SELECT IF(1<2, '1<2', '1>=2'), IF(NULL, 'Y', 'N');
-- result is: 1<2        N

```

`IFNULL(expr1, expr2)`函数。它接受两个参数，如果 expr1 不为空，返回 expr1 的值；否则，返回 expr2 的值。

```sql
SELECT e.first_name,
       e.last_name,
       IFNULL(e.commission_pct, 0)
  FROM employees e;

```



## 集合运算

SQL:2016（ISO/IEC 9075:2016）标准中定义的集合操作符（`UNION`、`INTERSECT`和`EXCEPT`）

SQL 基于关系代数；因此 ，SQL 中的表或查询结果与集合理论中的集合非常类似，表或查询结果中的行相当于集合中的元素。不过，它们之间也存在一些不同之处：

- 集合理论中的集合不允许存在重复的数据，但是 SQL 允许。因此，SQL 中的集合也被称为多重集合（multiset）；
- 多重集合与集合理论中的集合都是无序的，但是 SQL 查询结果可以通过ORDER BY子句进行排序。

SQL 中的集合操作符要求参与运算的表或查询结果具有相同数量的列，以及对应列的类型必须匹配或兼容。

### 并集（UNION）

`UNION`操作符用于将两个查询结果合并成一个结果集，包含了第一个查询结果以及第二个查询结果中的数据：

```sql
SELECT column1, column2
  FROM table1 
 UNION [DISTINCT | ALL]
SELECT col1, col2
  FROM table2;

```

其中，DISTINCT 表示将合并后的结果集进行去重；ALL 表示保留结果集中的重复记录；如果省略，默认为 DISTINCT。

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427104600.png"/>

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427104623.png"/>

示例：

```sql
SELECT d.department_id
  FROM departments d
 UNION 
SELECT e.department_id
  FROM employees e;

```

首选，分别执行两个查询，获取 departments 表中的部门编号和 employees 表中的部门编号；然后将它们进行合并操作，并且排除重复的记录。

以下语句执行了类似的操作，只是不进行重复值的删除：

```sql
SELECT d.department_id
  FROM departments d
 UNION ALL
SELECT e.department_id
  FROM employees e;

```

如果要对集合运算后的数据进行排序，需要将`ORDER BY`子句写在最后；`UNION`之前的查询中不能出现排序操作：

```sql
SELECT d.department_id
  FROM departments d
 UNION
SELECT e.department_id
  FROM employees e
 ORDER BY department_id;

```

对于分组操作，每个 SELECT 查询都可以包含一个`GROUP BY`，但是它们只针对各自进行分组；如果想要对最终结果进行分组，需要在外层增加一个 SELECT 语句：

```sql
SELECT tmp.department_id
  FROM (SELECT d.department_id
          FROM departments d
         UNION
        SELECT e.department_id
          FROM employees e) tmp
 GROUP BY tmp.department_id;

```

### 交集（INTERSECT）

`INTERSECT`操作符用于返回两个查询结果中的共同部分，即同时出现在第一个查询结果和第二个查询结果中的数据：

```sql
SELECT column1, column2
  FROM table1 
INTERSECT [DISTINCT | ALL]
SELECT col1, col2
  FROM table2;

```

其中，DISTINCT 表示将最终的结果集进行去重；ALL 表示保留结果集中的重复记录；如果省略，默认为 DISTINCT。参考以下示意图：

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427110404.png"/>

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427110432.png"/>

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427110452.png"/>

注意中间的示意图，虽然 result1 中包含两个 1，但是最终结果只有一个 1；因为 result2 中的 1 只能和 result1 中的一个 1 匹配。

> MySQL 不支持`INTERSECT`操作符；

以下示例使用`INTERSECT`获取所有经理的员工编号：

```sql
SELECT m.employee_id
  FROM employees m
INTERSECT
SELECT e.manager_id
  FROM employees e
 ORDER BY employee_id;

```

对于 MySQL，以上示例可以通过`JOIN`实现：

```sql
SELECT DISTINCT
       m.employee_id
  FROM employees m
  JOIN employees e
    ON (m.employee_id = e.manager_id)
 ORDER BY employee_id;

```

### 差集（EXCEPT）

`EXCEPT`操作符用于返回出现在第一个查询结果中，但不在第二个查询结果中的数据：

```sql
SELECT column1, column2
  FROM table1 
EXCEPT [DISTINCT | ALL]
SELECT col1, col2
  FROM table2;

```

其中，DISTINCT 表示将最终的结果集进行去重；ALL 表示保留结果集中的重复记录；如果省略，默认为 DISTINCT。

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427111536.png"/>

<img src="https://raw.githubusercontent.com/HG1227/image/master/img_tuchuang/20200427111557.png"/>

> MySQL 不支持`EXCEPT`操作符；
























































































参考：

<https://www.cnblogs.com/xiaohuochai/p/6081482.html>